// This file was auto-generated by Fern from our API Definition.

import * as Vital from "../../src/api/index";
import { VitalClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("VitalsClient", () => {
    test("workout_swimming_stroke_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 37,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/workout_swimming_stroke/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.workoutSwimmingStrokeGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 37,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("workout_swimming_stroke_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/workout_swimming_stroke/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.workoutSwimmingStrokeGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("workout_distance_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "m",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 37,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/workout_distance/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.workoutDistanceGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "m",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 37,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("workout_distance_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/workout_distance/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.workoutDistanceGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("heart_rate_recovery_one_minute_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 37,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heart_rate_recovery_one_minute/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.heartRateRecoveryOneMinuteGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 37,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("heart_rate_recovery_one_minute_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heart_rate_recovery_one_minute/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.heartRateRecoveryOneMinuteGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("waist_circumference_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "cm",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 90,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/waist_circumference/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.waistCircumferenceGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "cm",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 90,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("waist_circumference_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/waist_circumference/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.waistCircumferenceGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("lean_body_mass_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "kg",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 50,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/lean_body_mass/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.leanBodyMassGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "kg",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 50,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("lean_body_mass_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/lean_body_mass/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.leanBodyMassGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_mass_index_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "index",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 21,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_mass_index/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyMassIndexGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "index",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 21,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("body_mass_index_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_mass_index/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyMassIndexGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("basal_body_temperature_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "Â°C",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 36.7,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/basal_body_temperature/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.basalBodyTemperatureGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "\u00B0C",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 36.7,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("basal_body_temperature_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/basal_body_temperature/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.basalBodyTemperatureGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("handwashing_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/handwashing/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.handwashingGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("handwashing_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/handwashing/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.handwashingGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("daylight_exposure_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "min",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 45,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/daylight_exposure/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.daylightExposureGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "min",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 45,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("daylight_exposure_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/daylight_exposure/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.daylightExposureGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("uv_exposure_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "index",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/uv_exposure/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.uvExposureGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "index",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("uv_exposure_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/uv_exposure/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.uvExposureGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("fall_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 3,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/fall/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.fallGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 3,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("fall_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/fall/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.fallGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("inhaler_usage_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 2,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/inhaler_usage/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.inhalerUsageGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 2,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("inhaler_usage_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/inhaler_usage/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.inhalerUsageGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("peak_expiratory_flow_rate_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "L/min",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 450,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/peak_expiratory_flow_rate/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.peakExpiratoryFlowRateGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "L/min",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 450,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("peak_expiratory_flow_rate_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/peak_expiratory_flow_rate/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.peakExpiratoryFlowRateGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("forced_vital_capacity_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "L",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 4.2,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/forced_vital_capacity/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.forcedVitalCapacityGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 4.2,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("forced_vital_capacity_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/forced_vital_capacity/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.forcedVitalCapacityGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("forced_expiratory_volume_1_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "L",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 3.5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/forced_expiratory_volume_1/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.forcedExpiratoryVolume1Grouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 3.5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("forced_expiratory_volume_1_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/forced_expiratory_volume_1/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.forcedExpiratoryVolume1Grouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("wheelchair_push_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 52,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/wheelchair_push/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.wheelchairPushGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 52,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("wheelchair_push_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/wheelchair_push/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.wheelchairPushGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("sleep_breathing_disturbance_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                type: "elevated",
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 12,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/sleep_breathing_disturbance/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.sleepBreathingDisturbanceGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "elevated",
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 12,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("sleep_breathing_disturbance_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/sleep_breathing_disturbance/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.sleepBreathingDisturbanceGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("sleep_apnea_alert_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/sleep_apnea_alert/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.sleepApneaAlertGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("sleep_apnea_alert_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/sleep_apnea_alert/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.sleepApneaAlertGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("stand_duration_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "min",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 15,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stand_duration/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.standDurationGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "min",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 15,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("stand_duration_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stand_duration/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.standDurationGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("stand_hour_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                type: "stood",
                                unit: "count",
                                timestamp: "2023-02-13T14:30:52Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stand_hour/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.standHourGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "stood",
                                unit: "count",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("stand_hour_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stand_hour/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.standHourGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("heart_rate_alert_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                type: "irregular_rhythm",
                                unit: "count",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heart_rate_alert/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.heartRateAlertGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "irregular_rhythm",
                                unit: "count",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("heart_rate_alert_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heart_rate_alert/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.heartRateAlertGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("afib_burden_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "%",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: 3,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/afib_burden/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.afibBurdenGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "%",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: 3,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("afib_burden_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/afib_burden/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.afibBurdenGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("workout_duration_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "min",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: 48,
                                intensity: "medium",
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/workout_duration/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.workoutDurationGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "min",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: 48,
                                intensity: "medium",
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("workout_duration_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/workout_duration/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.workoutDurationGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("vo2_max_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "mL/kg/min",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 48,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/vo2_max/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.vo2MaxGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "mL/kg/min",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 48,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("vo2_max_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/vo2_max/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.vo2MaxGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("stress_level_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "%", timestamp: "2023-02-13T14:30:52Z", value: 35 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stress_level/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.stressLevelGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "%",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 35,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("stress_level_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stress_level/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.stressLevelGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("mindfulness_minutes_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "min",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:57:24Z",
                                end: "2026-01-15T18:49:25Z",
                                value: 42,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/mindfulness_minutes/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.mindfulnessMinutesGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "min",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:57:24.000Z"),
                                end: new Date("2026-01-15T18:49:25.000Z"),
                                value: 42,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("mindfulness_minutes_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/mindfulness_minutes/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.mindfulnessMinutesGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("caffeine_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "g",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 42,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/caffeine/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.caffeineGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "g",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 42,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("caffeine_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/caffeine/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.caffeineGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("water_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "ml", timestamp: "2024-01-15T09:30:00Z", value: 400 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/water/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.waterGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "ml",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                value: 400,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("water_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/water/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.waterGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("steps_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "count",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 123,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/steps/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.stepsGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 123,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("steps_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/steps/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.stepsGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("floors_climbed_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "count", timestamp: "2024-01-15T09:30:00Z", value: 2 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/floors_climbed/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.floorsClimbedGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "count",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                value: 2,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("floors_climbed_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/floors_climbed/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.floorsClimbedGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("distance_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "m",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 5.6,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/distance/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.distanceGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "m",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 5.6,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("distance_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/distance/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.distanceGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("calories_basal_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "kcal", timestamp: "2024-01-15T09:30:00Z", value: 22.8 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_basal/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.caloriesBasalGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "kcal",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                value: 22.8,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("calories_basal_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_basal/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.caloriesBasalGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("calories_active_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "kcal",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 184,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_active/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.caloriesActiveGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "kcal",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 184,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("calories_active_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_active/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.caloriesActiveGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("respiratory_rate_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "bpm", timestamp: "2023-02-13T14:30:52Z", value: 15.5 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/respiratory_rate/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.respiratoryRateGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "bpm",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 15.5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("respiratory_rate_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/respiratory_rate/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.respiratoryRateGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("note_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "text",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: "Lorem ipsum dolor sit amet",
                                tags: ["food", "exercise"],
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/note/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.noteGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "text",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: "Lorem ipsum dolor sit amet",
                                tags: ["food", "exercise"],
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("note_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/note/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.noteGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("insulin_injection_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                type: "long_acting",
                                unit: "unit",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: 60,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/insulin_injection/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.insulinInjectionGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "long_acting",
                                unit: "unit",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: 60,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("insulin_injection_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/insulin_injection/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.insulinInjectionGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("ige_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ type: "baha_grass", unit: "FSU", timestamp: "2023-02-13T14:30:52Z", value: 70 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/ige/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.igeGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "baha_grass",
                                unit: "FSU",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 70,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("ige_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/ige/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.igeGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("igg_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ type: "dairy", unit: "FSU", timestamp: "2023-02-13T14:30:52Z", value: 12 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/igg/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.iggGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "dairy",
                                unit: "FSU",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 12,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("igg_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/igg/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.iggGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("hypnogram_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "stage",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hypnogram/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.hypnogramGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "stage",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: 1,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("hypnogram_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hypnogram/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.hypnogramGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("hrv_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "rmssd", timestamp: "2023-02-13T14:30:52Z", value: 48 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hrv/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.hrvGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "rmssd",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 48,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("hrv_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hrv/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.hrvGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("heartrate_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "bpm", timestamp: "2023-02-13T14:30:52Z", value: 70 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heartrate/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.heartrateGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "bpm",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 70,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("heartrate_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heartrate/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.heartrateGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("glucose_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                type: "automatic | manual_scan",
                                unit: "mmol/L",
                                timestamp: "2023-02-13T14:30:52Z",
                                value: 0.5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/glucose/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.glucoseGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "automatic | manual_scan",
                                unit: "mmol/L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 0.5,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("glucose_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/glucose/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.glucoseGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("cholesterol_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            { type: "cholesterol/ldl", unit: "mmol/L", timestamp: "2023-02-13T14:30:52Z", value: 0.6 },
                            { type: "cholesterol/hdl", unit: "mmol/L", timestamp: "2023-02-13T14:30:52Z", value: 0.2 },
                            {
                                type: "cholesterol/total",
                                unit: "mmol/L",
                                timestamp: "2023-02-13T14:30:52Z",
                                value: 0.7,
                            },
                            {
                                type: "cholesterol/triglycerides",
                                unit: "mmol/L",
                                timestamp: "2023-02-13T14:30:52Z",
                                value: 0.7,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.cholesterolGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "cholesterol/ldl",
                                unit: "mmol/L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 0.6,
                            },
                            {
                                type: "cholesterol/hdl",
                                unit: "mmol/L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 0.2,
                            },
                            {
                                type: "cholesterol/total",
                                unit: "mmol/L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 0.7,
                            },
                            {
                                type: "cholesterol/triglycerides",
                                unit: "mmol/L",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 0.7,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("cholesterol_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.cholesterolGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("carbohydrates_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "g",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: 30,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/carbohydrates/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.carbohydratesGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "g",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: 30,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("carbohydrates_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/carbohydrates/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.carbohydratesGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_temperature_delta_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "Â°C",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:57:24Z",
                                value: -1,
                                sensor_location: "wrist",
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_temperature_delta/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyTemperatureDeltaGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "\u00B0C",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:57:24.000Z"),
                                value: -1,
                                sensorLocation: "wrist",
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("body_temperature_delta_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_temperature_delta/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyTemperatureDeltaGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_temperature_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [
                            {
                                unit: "Â°C",
                                timestamp: "2024-01-15T09:30:00Z",
                                start: "2023-02-13T14:30:52Z",
                                end: "2023-02-13T14:30:52Z",
                                value: 65,
                                sensor_location: "eardrum",
                            },
                        ],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_temperature/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyTemperatureGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "\u00B0C",
                                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                                start: new Date("2023-02-13T14:30:52.000Z"),
                                end: new Date("2023-02-13T14:30:52.000Z"),
                                value: 65,
                                sensorLocation: "eardrum",
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("body_temperature_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_temperature/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyTemperatureGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_weight_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "kg", timestamp: "2023-02-13T14:30:52Z", value: 65 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_weight/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyWeightGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "kg",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 65,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("body_weight_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_weight/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyWeightGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_fat_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "%", timestamp: "2023-02-13T14:30:52Z", value: 50 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_fat/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyFatGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "%",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 50,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("body_fat_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_fat/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyFatGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("blood_oxygen_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "%", timestamp: "2023-02-13T14:30:52Z", value: 98 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_oxygen/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bloodOxygenGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "%",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: 98,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("blood_oxygen_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_oxygen/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bloodOxygenGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("electrocardiogram_voltage_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ type: "lead_1", unit: "mV", timestamp: "2023-02-13T14:30:52Z", value: -373 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/electrocardiogram_voltage/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.electrocardiogramVoltageGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                type: "lead_1",
                                unit: "mV",
                                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                                value: -373,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("electrocardiogram_voltage_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/electrocardiogram_voltage/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.electrocardiogramVoltageGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("blood_pressure_grouped (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            groups: {
                oura: [
                    {
                        source: { provider: "oura", type: "ring" },
                        data: [{ unit: "mmHg", timestamp: "2026-01-15T18:44:25Z", systolic: 125, diastolic: 75 }],
                    },
                ],
            },
            next: "next",
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_pressure/grouped")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bloodPressureGrouped("user_id", {
            cursor: "cursor",
            nextCursor: "next_cursor",
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual({
            groups: {
                oura: [
                    {
                        source: {
                            provider: "oura",
                            type: "ring",
                        },
                        data: [
                            {
                                unit: "mmHg",
                                timestamp: new Date("2026-01-15T18:44:25.000Z"),
                                systolic: 125,
                                diastolic: 75,
                            },
                        ],
                    },
                ],
            },
            next: "next",
            nextCursor: "next_cursor",
        });
    });

    test("blood_pressure_grouped (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_pressure/grouped")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bloodPressureGrouped("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("vo2_max (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "mL/kg/min",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:30:52Z",
                end: "2023-02-13T14:57:24Z",
                value: 48,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/vo2_max")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.vo2Max("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "mL/kg/min",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:30:52.000Z"),
                end: new Date("2023-02-13T14:57:24.000Z"),
                value: 48,
            },
        ]);
    });

    test("vo2_max (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/vo2_max")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.vo2Max("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("stress_level (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "%", timestamp: "2023-02-13T14:30:52Z", value: 35 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stress_level")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.stressLevel("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "%",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 35,
            },
        ]);
    });

    test("stress_level (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/stress_level")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.stressLevel("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("mindfulness_minutes (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "min",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:57:24Z",
                end: "2026-01-15T18:49:25Z",
                value: 42,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/mindfulness_minutes")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.mindfulnessMinutes("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "min",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:57:24.000Z"),
                end: new Date("2026-01-15T18:49:25.000Z"),
                value: 42,
            },
        ]);
    });

    test("mindfulness_minutes (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/mindfulness_minutes")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.mindfulnessMinutes("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("caffeine (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "g",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:30:52Z",
                end: "2023-02-13T14:57:24Z",
                value: 42,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/caffeine")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.caffeine("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "g",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:30:52.000Z"),
                end: new Date("2023-02-13T14:57:24.000Z"),
                value: 42,
            },
        ]);
    });

    test("caffeine (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/caffeine")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.caffeine("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("water (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "ml", timestamp: "2024-01-15T09:30:00Z", value: 400 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/water")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.water("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "ml",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                value: 400,
            },
        ]);
    });

    test("water (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/water")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.water("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("steps (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "count",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:30:52Z",
                end: "2023-02-13T14:57:24Z",
                value: 123,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/steps")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.steps("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "count",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:30:52.000Z"),
                end: new Date("2023-02-13T14:57:24.000Z"),
                value: 123,
            },
        ]);
    });

    test("steps (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/steps")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.steps("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("floors_climbed (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "count", timestamp: "2024-01-15T09:30:00Z", value: 2 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/floors_climbed")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.floorsClimbed("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "count",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                value: 2,
            },
        ]);
    });

    test("floors_climbed (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/floors_climbed")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.floorsClimbed("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("distance (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "m",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:30:52Z",
                end: "2023-02-13T14:57:24Z",
                value: 5.6,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/distance")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.distance("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "m",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:30:52.000Z"),
                end: new Date("2023-02-13T14:57:24.000Z"),
                value: 5.6,
            },
        ]);
    });

    test("distance (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/distance")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.distance("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("calories_basal (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "kcal", timestamp: "2024-01-15T09:30:00Z", value: 22.8 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_basal")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.caloriesBasal("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "kcal",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                value: 22.8,
            },
        ]);
    });

    test("calories_basal (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_basal")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.caloriesBasal("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("calories_active (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "kcal",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:30:52Z",
                end: "2023-02-13T14:57:24Z",
                value: 184,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_active")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.caloriesActive("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "kcal",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:30:52.000Z"),
                end: new Date("2023-02-13T14:57:24.000Z"),
                value: 184,
            },
        ]);
    });

    test("calories_active (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/calories_active")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.caloriesActive("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("respiratory_rate (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "bpm", timestamp: "2023-02-13T14:30:52Z", value: 15.5 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/respiratory_rate")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.respiratoryRate("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "bpm",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 15.5,
            },
        ]);
    });

    test("respiratory_rate (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/respiratory_rate")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.respiratoryRate("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("ige (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "baha_grass",
                unit: "FSU",
                timestamp: "2023-02-13T14:30:52Z",
                value: 70,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/ige")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.ige("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "baha_grass",
                unit: "FSU",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 70,
            },
        ]);
    });

    test("ige (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/ige")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.ige("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("igg (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "dairy", unit: "FSU", timestamp: "2023-02-13T14:30:52Z", value: 12 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/igg")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.igg("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "dairy",
                unit: "FSU",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 12,
            },
        ]);
    });

    test("igg (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/igg")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.igg("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("hypnogram (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "stage",
                timestamp: "2024-01-15T09:30:00Z",
                start: "2023-02-13T14:30:52Z",
                end: "2023-02-13T14:57:24Z",
                value: 1,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hypnogram")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.hypnogram("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "stage",
                timestamp: new Date("2024-01-15T09:30:00.000Z"),
                start: new Date("2023-02-13T14:30:52.000Z"),
                end: new Date("2023-02-13T14:57:24.000Z"),
                value: 1,
            },
        ]);
    });

    test("hypnogram (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hypnogram")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.hypnogram("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("hrv (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "rmssd", timestamp: "2023-02-13T14:30:52Z", value: 48 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hrv")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.hrv("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "rmssd",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 48,
            },
        ]);
    });

    test("hrv (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/hrv")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.hrv("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("heartrate (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "bpm", timestamp: "2023-02-13T14:30:52Z", value: 70 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heartrate")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.heartrate("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "bpm",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 70,
            },
        ]);
    });

    test("heartrate (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/heartrate")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.heartrate("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("glucose (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "automatic | manual_scan",
                unit: "mmol/L",
                timestamp: "2023-02-13T14:30:52Z",
                value: 0.5,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/glucose")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.glucose("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "automatic | manual_scan",
                unit: "mmol/L",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 0.5,
            },
        ]);
    });

    test("glucose (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/glucose")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.glucose("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("cholesterol/triglycerides (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: "2023-02-13T14:30:52Z",
                value: 0.6,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/triglycerides")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.cholesterolTriglycerides("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 0.6,
            },
        ]);
    });

    test("cholesterol/triglycerides (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/triglycerides")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.cholesterolTriglycerides("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("cholesterol/total (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: "2023-02-13T14:30:52Z",
                value: 0.6,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/total")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.cholesterolTotal("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 0.6,
            },
        ]);
    });

    test("cholesterol/total (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/total")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.cholesterolTotal("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("cholesterol/ldl (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: "2023-02-13T14:30:52Z",
                value: 0.6,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/ldl")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.cholesterolLdl("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 0.6,
            },
        ]);
    });

    test("cholesterol/ldl (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/ldl")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.cholesterolLdl("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("cholesterol/hdl (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: "2023-02-13T14:30:52Z",
                value: 0.6,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/hdl")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.cholesterolHdl("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 0.6,
            },
        ]);
    });

    test("cholesterol/hdl (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol/hdl")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.cholesterolHdl("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("cholesterol (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: "2023-02-13T14:30:52Z",
                value: 0.6,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.cholesterol("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "cholesterol/ldl",
                unit: "mmol/L",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 0.6,
            },
        ]);
    });

    test("cholesterol (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/cholesterol")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.cholesterol("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_weight (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "kg", timestamp: "2023-02-13T14:30:52Z", value: 65 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_weight")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyWeight("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "kg",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 65,
            },
        ]);
    });

    test("body_weight (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_weight")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyWeight("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("body_fat (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "%", timestamp: "2023-02-13T14:30:52Z", value: 50 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_fat")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bodyFat("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "%",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 50,
            },
        ]);
    });

    test("body_fat (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/body_fat")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bodyFat("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("blood_oxygen (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "type", unit: "%", timestamp: "2023-02-13T14:30:52Z", value: 98 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_oxygen")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bloodOxygen("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "%",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: 98,
            },
        ]);
    });

    test("blood_oxygen (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_oxygen")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bloodOxygen("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("electrocardiogram_voltage (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            { id: 1, timezone_offset: 1, type: "lead_1", unit: "mV", timestamp: "2023-02-13T14:30:52Z", value: -373 },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/electrocardiogram_voltage")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.electrocardiogramVoltage("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "lead_1",
                unit: "mV",
                timestamp: new Date("2023-02-13T14:30:52.000Z"),
                value: -373,
            },
        ]);
    });

    test("electrocardiogram_voltage (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/electrocardiogram_voltage")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.electrocardiogramVoltage("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("blood_pressure (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: 1,
                timezone_offset: 1,
                type: "type",
                unit: "mmHg",
                grouping: [{ key: "value" }],
                timestamp: "2026-01-15T18:44:25Z",
                systolic: 125,
                diastolic: 75,
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_pressure")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.vitals.bloodPressure("user_id", {
            provider: "provider",
            startDate: "start_date",
            endDate: "end_date",
        });
        expect(response).toEqual([
            {
                id: 1,
                timezoneOffset: 1,
                type: "type",
                unit: "mmHg",
                grouping: [
                    {
                        key: "value",
                    },
                ],
                timestamp: new Date("2026-01-15T18:44:25.000Z"),
                systolic: 125,
                diastolic: 75,
            },
        ]);
    });

    test("blood_pressure (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/timeseries/user_id/blood_pressure")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.vitals.bloodPressure("user_id", {
                startDate: "start_date",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });
});
