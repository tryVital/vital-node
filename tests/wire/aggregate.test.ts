// This file was auto-generated by Fern from our API Definition.

import * as Vital from "../../src/api/index";
import { VitalClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("AggregateClient", () => {
    test("query_one (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            timeframe: { type: "relative", anchor: "anchor", past: { unit: "minute" } },
            queries: [{ select: [{ arg: { sleep: "id" }, func: "mean" }] }],
        };
        const rawResponseBody = { results: [{ table: { key: [] } }] };
        server
            .mockEndpoint()
            .post("/aggregate/v1/user/user_id/query")
            .header("accept", "*/*")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.aggregate.queryOne("user_id", {
            timeframe: {
                type: "relative",
                anchor: "anchor",
                past: {
                    unit: "minute",
                },
            },
            queries: [
                {
                    select: [
                        {
                            arg: {
                                sleep: "id",
                            },
                            func: "mean",
                        },
                    ],
                },
            ],
        });
        expect(response).toEqual({
            results: [
                {
                    table: {
                        key: [],
                    },
                },
            ],
        });
    });

    test("query_one (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            timeframe: { type: "relative", anchor: "anchor", past: { unit: "minute" } },
            queries: [
                {
                    select: [
                        { arg: { sleep: "id" }, func: "mean" },
                        { arg: { sleep: "id" }, func: "mean" },
                    ],
                },
                {
                    select: [
                        { arg: { sleep: "id" }, func: "mean" },
                        { arg: { sleep: "id" }, func: "mean" },
                    ],
                },
            ],
        };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/aggregate/v1/user/user_id/query")
            .header("accept", "*/*")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.aggregate.queryOne("user_id", {
                timeframe: {
                    type: "relative",
                    anchor: "anchor",
                    past: {
                        unit: "minute",
                    },
                },
                queries: [
                    {
                        select: [
                            {
                                arg: {
                                    sleep: "id",
                                },
                                func: "mean",
                            },
                            {
                                arg: {
                                    sleep: "id",
                                },
                                func: "mean",
                            },
                        ],
                    },
                    {
                        select: [
                            {
                                arg: {
                                    sleep: "id",
                                },
                                func: "mean",
                            },
                            {
                                arg: {
                                    sleep: "id",
                                },
                                func: "mean",
                            },
                        ],
                    },
                ],
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_result_table_for_continuous_query (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { table: { key: [{ key: "value" }] } };
        server
            .mockEndpoint()
            .get("/aggregate/v1/user/user_id/continuous_query/query_id_or_slug/result_table")
            .header("accept", "*/*")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.aggregate.getResultTableForContinuousQuery("user_id", "query_id_or_slug");
        expect(response).toEqual({
            table: {
                key: [
                    {
                        key: "value",
                    },
                ],
            },
        });
    });

    test("get_result_table_for_continuous_query (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/aggregate/v1/user/user_id/continuous_query/query_id_or_slug/result_table")
            .header("accept", "*/*")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.aggregate.getResultTableForContinuousQuery("user_id", "query_id_or_slug");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_task_history_for_continuous_query (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    query_id: "query_id",
                    user_id: "user_id",
                    status: "scheduled",
                    scheduled_at: "2024-01-15T09:30:00Z",
                    started_at: "2024-01-15T09:30:00Z",
                    ended_at: "2024-01-15T09:30:00Z",
                    error_details: "error_details",
                },
            ],
            next_cursor: "next_cursor",
        };
        server
            .mockEndpoint()
            .get("/aggregate/v1/user/user_id/continuous_query/query_id_or_slug/task_history")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.aggregate.getTaskHistoryForContinuousQuery("user_id", "query_id_or_slug", {
            nextCursor: "next_cursor",
            limit: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    queryId: "query_id",
                    userId: "user_id",
                    status: "scheduled",
                    scheduledAt: new Date("2024-01-15T09:30:00.000Z"),
                    startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    endedAt: new Date("2024-01-15T09:30:00.000Z"),
                    errorDetails: "error_details",
                },
            ],
            nextCursor: "next_cursor",
        });
    });

    test("get_task_history_for_continuous_query (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/aggregate/v1/user/user_id/continuous_query/query_id_or_slug/task_history")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.aggregate.getTaskHistoryForContinuousQuery("user_id", "query_id_or_slug");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });
});
