// This file was auto-generated by Fern from our API Definition.

import * as Vital from "../../src/api/index";
import { VitalClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("UserClient", () => {
    test("get_all (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            users: [
                {
                    user_id: "56bd81c9-6219-4000-a775-ae85526eba18",
                    team_id: "56bd81c9-6219-4000-a775-ae85526eba18",
                    client_user_id: "ZTEwZjNjMjctOTI2ZS00M2Vm",
                    created_on: "2026-01-07T18:35:37Z",
                    connected_sources: [
                        {
                            provider: { name: "Oura", slug: "oura", logo: "https://logo_url.com" },
                            created_on: "2026-01-07T18:35:37Z",
                            source: { name: "Oura", slug: "oura", logo: "logo_url" },
                        },
                    ],
                    fallback_time_zone: {
                        id: "Europe/London",
                        source_slug: "manual",
                        updated_at: "2026-01-07T18:35:37Z",
                    },
                    fallback_birth_date: {
                        value: "1989-09-12",
                        source_slug: "manual",
                        updated_at: "2026-01-07T18:35:37Z",
                    },
                    ingestion_start: "ingestion_start",
                    ingestion_end: "ingestion_end",
                },
            ],
            total: 1,
            offset: 1,
            limit: 1,
        };
        server.mockEndpoint().get("/v2/user").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.user.getAll({
            offset: 1,
            limit: 1,
        });
        expect(response).toEqual({
            users: [
                {
                    userId: "56bd81c9-6219-4000-a775-ae85526eba18",
                    teamId: "56bd81c9-6219-4000-a775-ae85526eba18",
                    clientUserId: "ZTEwZjNjMjctOTI2ZS00M2Vm",
                    createdOn: new Date("2026-01-07T18:35:37.000Z"),
                    connectedSources: [
                        {
                            provider: {
                                name: "Oura",
                                slug: "oura",
                                logo: "https://logo_url.com",
                            },
                            createdOn: new Date("2026-01-07T18:35:37.000Z"),
                            source: {
                                name: "Oura",
                                slug: "oura",
                                logo: "logo_url",
                            },
                        },
                    ],
                    fallbackTimeZone: {
                        id: "Europe/London",
                        sourceSlug: "manual",
                        updatedAt: new Date("2026-01-07T18:35:37.000Z"),
                    },
                    fallbackBirthDate: {
                        value: "1989-09-12",
                        sourceSlug: "manual",
                        updatedAt: new Date("2026-01-07T18:35:37.000Z"),
                    },
                    ingestionStart: "ingestion_start",
                    ingestionEnd: "ingestion_end",
                },
            ],
            total: 1,
            offset: 1,
            limit: 1,
        });
    });

    test("get_all (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server.mockEndpoint().get("/v2/user").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.user.getAll();
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("create (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { client_user_id: "client_user_id" };
        const rawResponseBody = {
            user_id: "1449752e-0d8a-40e0-9206-91ab099b2537",
            client_user_id: "ZTEwZjNjMjctOTI2ZS00M2Vm",
        };
        server
            .mockEndpoint()
            .post("/v2/user")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.create({
            clientUserId: "client_user_id",
        });
        expect(response).toEqual({
            userId: "1449752e-0d8a-40e0-9206-91ab099b2537",
            clientUserId: "ZTEwZjNjMjctOTI2ZS00M2Vm",
        });
    });

    test("create (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { client_user_id: "client_user_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v2/user")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.create({
                clientUserId: "client_user_id",
            });
        }).rejects.toThrow(Vital.BadRequestError);
    });

    test("create (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { client_user_id: "client_user_id" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v2/user")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.create({
                clientUserId: "client_user_id",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_team_metrics", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            team_id: "team_id",
            number_of_connected_sources: 1,
            number_of_users: 1,
            number_of_errored_connected_sources: 1,
            number_of_connected_sources_by_week: [{ date: "2024-01-15T09:30:00Z", value: 1.1, all: 1.1 }],
            number_of_ordered_tests: 1,
        };
        server.mockEndpoint().get("/v2/user/metrics").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.user.getTeamMetrics();
        expect(response).toEqual({
            teamId: "team_id",
            numberOfConnectedSources: 1,
            numberOfUsers: 1,
            numberOfErroredConnectedSources: 1,
            numberOfConnectedSourcesByWeek: [
                {
                    date: new Date("2024-01-15T09:30:00.000Z"),
                    value: 1.1,
                    all: 1.1,
                },
            ],
            numberOfOrderedTests: 1,
        });
    });

    test("get_connected_providers (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            key: [
                {
                    name: "Garmin",
                    slug: "garmin",
                    logo: "https://logo_url.com",
                    created_on: "2010-01-23T12:34:56Z",
                    status: "error",
                    external_user_id: "external_user_id",
                    error_details: {
                        error_type: "deregistered_per_provider",
                        error_message: "The user has deregistered the connection per notification from Garmin.",
                        errored_at: "2010-01-24T23:45:32Z",
                    },
                    resource_availability: {
                        sleep: {
                            status: "available",
                            scope_requirements: {
                                user_granted: { required: ["daily"], optional: ["optional"] },
                                user_denied: { required: ["required"], optional: ["spo2Daily"] },
                            },
                        },
                    },
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v2/user/providers/user_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getConnectedProviders("user_id");
        expect(response).toEqual({
            key: [
                {
                    name: "Garmin",
                    slug: "garmin",
                    logo: "https://logo_url.com",
                    createdOn: new Date("2010-01-23T12:34:56.000Z"),
                    status: "error",
                    externalUserId: "external_user_id",
                    errorDetails: {
                        errorType: "deregistered_per_provider",
                        errorMessage: "The user has deregistered the connection per notification from Garmin.",
                        erroredAt: new Date("2010-01-24T23:45:32.000Z"),
                    },
                    resourceAvailability: {
                        sleep: {
                            status: "available",
                            scopeRequirements: {
                                userGranted: {
                                    required: ["daily"],
                                    optional: ["optional"],
                                },
                                userDenied: {
                                    required: ["required"],
                                    optional: ["spo2Daily"],
                                },
                            },
                        },
                    },
                },
            ],
        });
    });

    test("get_connected_providers (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/user/providers/user_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getConnectedProviders("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_latest_user_info (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            first_name: "first_name",
            last_name: "last_name",
            email: "email",
            phone_number: "phone_number",
            gender: "gender",
            dob: "dob",
            address: {
                first_line: "first_line",
                second_line: "second_line",
                country: "country",
                zip: "zip",
                city: "city",
                state: "state",
            },
            medical_proxy: {
                first_name: "first_name",
                last_name: "last_name",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phone_number: "phone_number",
                household_income: 1,
                household_size: 1,
                email: "email",
            },
            race: "african_american_or_black",
            ethnicity: "hispanic",
            sexual_orientation: "lesbian_gay_or_homosexual",
            gender_identity: "male",
        };
        server
            .mockEndpoint()
            .get("/v2/user/user_id/info/latest")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getLatestUserInfo("user_id");
        expect(response).toEqual({
            firstName: "first_name",
            lastName: "last_name",
            email: "email",
            phoneNumber: "phone_number",
            gender: "gender",
            dob: "dob",
            address: {
                firstLine: "first_line",
                secondLine: "second_line",
                country: "country",
                zip: "zip",
                city: "city",
                state: "state",
            },
            medicalProxy: {
                firstName: "first_name",
                lastName: "last_name",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phoneNumber: "phone_number",
                householdIncome: 1,
                householdSize: 1,
                email: "email",
            },
            race: "african_american_or_black",
            ethnicity: "hispanic",
            sexualOrientation: "lesbian_gay_or_homosexual",
            genderIdentity: "male",
        });
    });

    test("get_latest_user_info (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/user/user_id/info/latest")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getLatestUserInfo("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("create_insurance (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            payor_code: "payor_code",
            member_id: "member_id",
            relationship: "Self",
            insured: {
                first_name: "first_name",
                last_name: "last_name",
                gender: "female",
                address: { first_line: "first_line", country: "country", zip: "zip", city: "city", state: "state" },
                dob: "dob",
                email: "email",
                phone_number: "phone_number",
            },
        };
        const rawResponseBody = {
            member_id: "member_id",
            payor_code: "payor_code",
            relationship: "Self",
            insured: {
                first_name: "first_name",
                last_name: "last_name",
                gender: "female",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                dob: "dob",
                email: "email",
                phone_number: "phone_number",
            },
            company: {
                name: "name",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
            },
            group_id: "group_id",
            guarantor: {
                first_name: "first_name",
                last_name: "last_name",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phone_number: "phone_number",
                household_income: 1,
                household_size: 1,
                email: "email",
            },
            is_primary: true,
        };
        server
            .mockEndpoint()
            .post("/v2/user/user_id/insurance")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.createInsurance("user_id", {
            payorCode: "payor_code",
            memberId: "member_id",
            relationship: "Self",
            insured: {
                firstName: "first_name",
                lastName: "last_name",
                gender: "female",
                address: {
                    firstLine: "first_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                dob: "dob",
                email: "email",
                phoneNumber: "phone_number",
            },
        });
        expect(response).toEqual({
            memberId: "member_id",
            payorCode: "payor_code",
            relationship: "Self",
            insured: {
                firstName: "first_name",
                lastName: "last_name",
                gender: "female",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                dob: "dob",
                email: "email",
                phoneNumber: "phone_number",
            },
            company: {
                name: "name",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
            },
            groupId: "group_id",
            guarantor: {
                firstName: "first_name",
                lastName: "last_name",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phoneNumber: "phone_number",
                householdIncome: 1,
                householdSize: 1,
                email: "email",
            },
            isPrimary: true,
        });
    });

    test("create_insurance (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            payor_code: "payor_code",
            member_id: "member_id",
            relationship: "Self",
            insured: {
                first_name: "first_name",
                last_name: "last_name",
                gender: "female",
                address: { first_line: "first_line", country: "country", zip: "zip", city: "city", state: "state" },
                dob: "dob",
                email: "email",
                phone_number: "phone_number",
            },
        };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v2/user/user_id/insurance")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.createInsurance("user_id", {
                payorCode: "payor_code",
                memberId: "member_id",
                relationship: "Self",
                insured: {
                    firstName: "first_name",
                    lastName: "last_name",
                    gender: "female",
                    address: {
                        firstLine: "first_line",
                        country: "country",
                        zip: "zip",
                        city: "city",
                        state: "state",
                    },
                    dob: "dob",
                    email: "email",
                    phoneNumber: "phone_number",
                },
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_latest_insurance (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            member_id: "member_id",
            payor_code: "payor_code",
            relationship: "Self",
            insured: {
                first_name: "first_name",
                last_name: "last_name",
                gender: "female",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                dob: "dob",
                email: "email",
                phone_number: "phone_number",
            },
            company: {
                name: "name",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
            },
            group_id: "group_id",
            guarantor: {
                first_name: "first_name",
                last_name: "last_name",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phone_number: "phone_number",
                household_income: 1,
                household_size: 1,
                email: "email",
            },
            is_primary: true,
        };
        server
            .mockEndpoint()
            .get("/v2/user/user_id/insurance/latest")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getLatestInsurance("user_id", {
            isPrimary: true,
        });
        expect(response).toEqual({
            memberId: "member_id",
            payorCode: "payor_code",
            relationship: "Self",
            insured: {
                firstName: "first_name",
                lastName: "last_name",
                gender: "female",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                dob: "dob",
                email: "email",
                phoneNumber: "phone_number",
            },
            company: {
                name: "name",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
            },
            groupId: "group_id",
            guarantor: {
                firstName: "first_name",
                lastName: "last_name",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phoneNumber: "phone_number",
                householdIncome: 1,
                householdSize: 1,
                email: "email",
            },
            isPrimary: true,
        });
    });

    test("get_latest_insurance (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/user/user_id/insurance/latest")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getLatestInsurance("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("upsert_user_info (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            first_name: "first_name",
            last_name: "last_name",
            email: "email",
            phone_number: "phone_number",
            gender: "gender",
            dob: "dob",
            address: { first_line: "first_line", country: "country", zip: "zip", city: "city", state: "state" },
        };
        const rawResponseBody = {
            first_name: "first_name",
            last_name: "last_name",
            email: "email",
            phone_number: "phone_number",
            gender: "gender",
            dob: "dob",
            address: {
                first_line: "first_line",
                second_line: "second_line",
                country: "country",
                zip: "zip",
                city: "city",
                state: "state",
            },
            medical_proxy: {
                first_name: "first_name",
                last_name: "last_name",
                address: {
                    first_line: "first_line",
                    second_line: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phone_number: "phone_number",
                household_income: 1,
                household_size: 1,
                email: "email",
            },
            race: "african_american_or_black",
            ethnicity: "hispanic",
            sexual_orientation: "lesbian_gay_or_homosexual",
            gender_identity: "male",
        };
        server
            .mockEndpoint()
            .patch("/v2/user/user_id/info")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.upsertUserInfo("user_id", {
            firstName: "first_name",
            lastName: "last_name",
            email: "email",
            phoneNumber: "phone_number",
            gender: "gender",
            dob: "dob",
            address: {
                firstLine: "first_line",
                country: "country",
                zip: "zip",
                city: "city",
                state: "state",
            },
        });
        expect(response).toEqual({
            firstName: "first_name",
            lastName: "last_name",
            email: "email",
            phoneNumber: "phone_number",
            gender: "gender",
            dob: "dob",
            address: {
                firstLine: "first_line",
                secondLine: "second_line",
                country: "country",
                zip: "zip",
                city: "city",
                state: "state",
            },
            medicalProxy: {
                firstName: "first_name",
                lastName: "last_name",
                address: {
                    firstLine: "first_line",
                    secondLine: "second_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
                phoneNumber: "phone_number",
                householdIncome: 1,
                householdSize: 1,
                email: "email",
            },
            race: "african_american_or_black",
            ethnicity: "hispanic",
            sexualOrientation: "lesbian_gay_or_homosexual",
            genderIdentity: "male",
        });
    });

    test("upsert_user_info (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            first_name: "first_name",
            last_name: "last_name",
            email: "email",
            phone_number: "phone_number",
            gender: "gender",
            dob: "dob",
            address: { first_line: "first_line", country: "country", zip: "zip", city: "city", state: "state" },
        };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .patch("/v2/user/user_id/info")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.upsertUserInfo("user_id", {
                firstName: "first_name",
                lastName: "last_name",
                email: "email",
                phoneNumber: "phone_number",
                gender: "gender",
                dob: "dob",
                address: {
                    firstLine: "first_line",
                    country: "country",
                    zip: "zip",
                    city: "city",
                    state: "state",
                },
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_by_client_user_id (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user_id: "56bd81c9-6219-4000-a775-ae85526eba18",
            team_id: "56bd81c9-6219-4000-a775-ae85526eba18",
            client_user_id: "ZTEwZjNjMjctOTI2ZS00M2Vm",
            created_on: "2026-01-07T18:35:37Z",
            connected_sources: [
                {
                    provider: { name: "Oura", slug: "oura", logo: "https://logo_url.com" },
                    created_on: "2026-01-07T18:35:37Z",
                    source: { name: "Oura", slug: "oura", logo: "logo_url" },
                },
            ],
            fallback_time_zone: { id: "Europe/London", source_slug: "manual", updated_at: "2026-01-07T18:35:37Z" },
            fallback_birth_date: { value: "1989-09-12", source_slug: "manual", updated_at: "2026-01-07T18:35:37Z" },
            ingestion_start: "ingestion_start",
            ingestion_end: "ingestion_end",
        };
        server
            .mockEndpoint()
            .get("/v2/user/resolve/client_user_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getByClientUserId("client_user_id");
        expect(response).toEqual({
            userId: "56bd81c9-6219-4000-a775-ae85526eba18",
            teamId: "56bd81c9-6219-4000-a775-ae85526eba18",
            clientUserId: "ZTEwZjNjMjctOTI2ZS00M2Vm",
            createdOn: new Date("2026-01-07T18:35:37.000Z"),
            connectedSources: [
                {
                    provider: {
                        name: "Oura",
                        slug: "oura",
                        logo: "https://logo_url.com",
                    },
                    createdOn: new Date("2026-01-07T18:35:37.000Z"),
                    source: {
                        name: "Oura",
                        slug: "oura",
                        logo: "logo_url",
                    },
                },
            ],
            fallbackTimeZone: {
                id: "Europe/London",
                sourceSlug: "manual",
                updatedAt: new Date("2026-01-07T18:35:37.000Z"),
            },
            fallbackBirthDate: {
                value: "1989-09-12",
                sourceSlug: "manual",
                updatedAt: new Date("2026-01-07T18:35:37.000Z"),
            },
            ingestionStart: "ingestion_start",
            ingestionEnd: "ingestion_end",
        });
    });

    test("get_by_client_user_id (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/user/resolve/client_user_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getByClientUserId("client_user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("deregister_provider (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true };
        server
            .mockEndpoint()
            .delete("/v2/user/user_id/oura")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.deregisterProvider("user_id", "oura");
        expect(response).toEqual({
            success: true,
        });
    });

    test("deregister_provider (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v2/user/user_id/oura")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.deregisterProvider("user_id", "oura");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user_id: "56bd81c9-6219-4000-a775-ae85526eba18",
            team_id: "56bd81c9-6219-4000-a775-ae85526eba18",
            client_user_id: "ZTEwZjNjMjctOTI2ZS00M2Vm",
            created_on: "2026-01-07T18:35:37Z",
            connected_sources: [
                {
                    provider: { name: "Oura", slug: "oura", logo: "https://logo_url.com" },
                    created_on: "2026-01-07T18:35:37Z",
                    source: { name: "Oura", slug: "oura", logo: "logo_url" },
                },
            ],
            fallback_time_zone: { id: "Europe/London", source_slug: "manual", updated_at: "2026-01-07T18:35:37Z" },
            fallback_birth_date: { value: "1989-09-12", source_slug: "manual", updated_at: "2026-01-07T18:35:37Z" },
            ingestion_start: "ingestion_start",
            ingestion_end: "ingestion_end",
        };
        server.mockEndpoint().get("/v2/user/user_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.user.get("user_id");
        expect(response).toEqual({
            userId: "56bd81c9-6219-4000-a775-ae85526eba18",
            teamId: "56bd81c9-6219-4000-a775-ae85526eba18",
            clientUserId: "ZTEwZjNjMjctOTI2ZS00M2Vm",
            createdOn: new Date("2026-01-07T18:35:37.000Z"),
            connectedSources: [
                {
                    provider: {
                        name: "Oura",
                        slug: "oura",
                        logo: "https://logo_url.com",
                    },
                    createdOn: new Date("2026-01-07T18:35:37.000Z"),
                    source: {
                        name: "Oura",
                        slug: "oura",
                        logo: "logo_url",
                    },
                },
            ],
            fallbackTimeZone: {
                id: "Europe/London",
                sourceSlug: "manual",
                updatedAt: new Date("2026-01-07T18:35:37.000Z"),
            },
            fallbackBirthDate: {
                value: "1989-09-12",
                sourceSlug: "manual",
                updatedAt: new Date("2026-01-07T18:35:37.000Z"),
            },
            ingestionStart: "ingestion_start",
            ingestionEnd: "ingestion_end",
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server.mockEndpoint().get("/v2/user/user_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.user.get("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true };
        server
            .mockEndpoint()
            .delete("/v2/user/user_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.delete("user_id");
        expect(response).toEqual({
            success: true,
        });
    });

    test("delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .delete("/v2/user/user_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.delete("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("patch (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};

        server.mockEndpoint().patch("/v2/user/user_id").jsonBody(rawRequestBody).respondWith().statusCode(200).build();

        const response = await client.user.patch("user_id");
        expect(response).toEqual(undefined);
    });

    test("patch (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .patch("/v2/user/user_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.patch("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("undo_delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true };
        server
            .mockEndpoint()
            .post("/v2/user/undo_delete")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.undoDelete({
            userId: "user_id",
            clientUserId: "client_user_id",
        });
        expect(response).toEqual({
            success: true,
        });
    });

    test("undo_delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v2/user/undo_delete")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.undoDelete();
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("refresh (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            success: true,
            user_id: "1449752e-0d8a-40e0-9206-91ab099b2537",
            refreshed_sources: [
                "withings/workouts",
                "withings/sleep",
                "withings/body",
                "withings/vitals/blood_pressure",
                "withings/activity",
            ],
            in_progress_sources: ["in_progress_sources"],
            failed_sources: ["oura/sleep"],
        };
        server
            .mockEndpoint()
            .post("/v2/user/refresh/user_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.refresh("user_id", {
            timeout: 1.1,
        });
        expect(response).toEqual({
            success: true,
            userId: "1449752e-0d8a-40e0-9206-91ab099b2537",
            refreshedSources: [
                "withings/workouts",
                "withings/sleep",
                "withings/body",
                "withings/vitals/blood_pressure",
                "withings/activity",
            ],
            inProgressSources: ["in_progress_sources"],
            failedSources: ["oura/sleep"],
        });
    });

    test("refresh (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v2/user/refresh/user_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.refresh("user_id");
        }).rejects.toThrow(Vital.BadRequestError);
    });

    test("refresh (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v2/user/refresh/user_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.refresh("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_devices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: "00000000-0000-0000-0000-000000000000",
                user_id: "00000000-0000-0000-0000-000000000000",
                provider: "fitbit",
                source_type: "scale",
                app_id: "app_id",
                device_manufacturer: "Fitbit",
                device_model: "Aria Air",
                device_version: "1.0",
                device_id: "F-31-A4C138BB9EF5",
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/user/user_id/device")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getDevices("user_id");
        expect(response).toEqual([
            {
                id: "00000000-0000-0000-0000-000000000000",
                userId: "00000000-0000-0000-0000-000000000000",
                provider: "fitbit",
                sourceType: "scale",
                appId: "app_id",
                deviceManufacturer: "Fitbit",
                deviceModel: "Aria Air",
                deviceVersion: "1.0",
                deviceId: "F-31-A4C138BB9EF5",
            },
        ]);
    });

    test("get_devices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/user/user_id/device")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getDevices("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_device (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "00000000-0000-0000-0000-000000000000",
            user_id: "00000000-0000-0000-0000-000000000000",
            provider: "fitbit",
            source_type: "scale",
            app_id: "app_id",
            device_manufacturer: "Fitbit",
            device_model: "Aria Air",
            device_version: "1.0",
            device_id: "F-31-A4C138BB9EF5",
        };
        server
            .mockEndpoint()
            .get("/v2/user/user_id/device/device_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getDevice("user_id", "device_id");
        expect(response).toEqual({
            id: "00000000-0000-0000-0000-000000000000",
            userId: "00000000-0000-0000-0000-000000000000",
            provider: "fitbit",
            sourceType: "scale",
            appId: "app_id",
            deviceManufacturer: "Fitbit",
            deviceModel: "Aria Air",
            deviceVersion: "1.0",
            deviceId: "F-31-A4C138BB9EF5",
        });
    });

    test("get_device (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/user/user_id/device/device_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getDevice("user_id", "device_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_user_sign_in_token (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { user_id: "user_id", sign_in_token: "sign_in_token" };
        server
            .mockEndpoint()
            .post("/v2/user/user_id/sign_in_token")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.getUserSignInToken("user_id");
        expect(response).toEqual({
            userId: "user_id",
            signInToken: "sign_in_token",
        });
    });

    test("get_user_sign_in_token (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v2/user/user_id/sign_in_token")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.getUserSignInToken("user_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("create_portal_url (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { context: "launch" };
        const rawResponseBody = { url: "url", expires_in: 1 };
        server
            .mockEndpoint()
            .post("/v2/user/user_id/create_portal_url")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.user.createPortalUrl("user_id", {
            context: "launch",
        });
        expect(response).toEqual({
            url: "url",
            expiresIn: 1,
        });
    });

    test("create_portal_url (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { context: "launch" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/v2/user/user_id/create_portal_url")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.user.createPortalUrl("user_id", {
                context: "launch",
            });
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });
});
