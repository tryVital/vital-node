// This file was auto-generated by Fern from our API Definition.

import * as Vital from "../../src/api/index";
import { VitalClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("TeamClient", () => {
    test("get_link_config (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v2/team/link/config")
            .header("x-vital-link-token", "x-vital-link-token")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.team.getLinkConfig({
            vitalLinkToken: "x-vital-link-token",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_link_config (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/team/link/config")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.team.getLinkConfig();
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            org_id: "org_id",
            name: "name",
            svix_app_id: "svix_app_id",
            client_id: "client_id",
            client_secret: "client_secret",
            airtable_api_key: "airtable_api_key",
            airtable_base_id: "airtable_base_id",
            webhook_secret: "webhook_secret",
            api_key: "api_key",
            api_keys: [
                {
                    label: "label",
                    value: "value",
                    team_id: "team_id",
                    id: "id",
                    created_at: "2024-01-15T09:30:00Z",
                    deleted_at: "2024-01-15T09:30:00Z",
                },
            ],
            configuration: {
                libreview: { practice_id: { key: "value" }, strip_tz: true },
                texts_enabled: true,
                push_historical_data: true,
                provider_raw_data: true,
                reject_duplicate_connection: true,
                sdk_per_device_activity_timeseries: true,
                partial_webhooks_enabled: true,
                minor_ordering_enabled: true,
                eds_preferences: { preferred: "cloud_pubsub", enabled: ["cloud_pubsub"] },
                event_type_prefixes: ["event_type_prefixes"],
            },
            testkits_texts_enabled: true,
            lab_tests_patient_communication_enabled: true,
            lab_tests_patient_sms_communication_enabled: true,
            lab_tests_patient_email_communication_enabled: true,
            logo_url: "logo_url",
            delegated_flow: "order_and_results_with_customer_physician_network",
            critical_result_notification_email: "critical_result_notification_email",
        };
        server.mockEndpoint().get("/v2/team/team_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.team.get("team_id");
        expect(response).toEqual({
            id: "id",
            orgId: "org_id",
            name: "name",
            svixAppId: "svix_app_id",
            clientId: "client_id",
            clientSecret: "client_secret",
            airtableApiKey: "airtable_api_key",
            airtableBaseId: "airtable_base_id",
            webhookSecret: "webhook_secret",
            apiKey: "api_key",
            apiKeys: [
                {
                    label: "label",
                    value: "value",
                    teamId: "team_id",
                    id: "id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    deletedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            configuration: {
                libreview: {
                    practiceId: {
                        key: "value",
                    },
                    stripTz: true,
                },
                textsEnabled: true,
                pushHistoricalData: true,
                providerRawData: true,
                rejectDuplicateConnection: true,
                sdkPerDeviceActivityTimeseries: true,
                partialWebhooksEnabled: true,
                minorOrderingEnabled: true,
                edsPreferences: {
                    preferred: "cloud_pubsub",
                    enabled: ["cloud_pubsub"],
                },
                eventTypePrefixes: ["event_type_prefixes"],
            },
            testkitsTextsEnabled: true,
            labTestsPatientCommunicationEnabled: true,
            labTestsPatientSmsCommunicationEnabled: true,
            labTestsPatientEmailCommunicationEnabled: true,
            logoUrl: "logo_url",
            delegatedFlow: "order_and_results_with_customer_physician_network",
            criticalResultNotificationEmail: "critical_result_notification_email",
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server.mockEndpoint().get("/v2/team/team_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.team.get("team_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_user_by_id (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                user_id: "56bd81c9-6219-4000-a775-ae85526eba18",
                team_id: "56bd81c9-6219-4000-a775-ae85526eba18",
                client_user_id: "ZTEwZjNjMjctOTI2ZS00M2Vm",
                created_on: "2026-01-06T17:44:21Z",
                connected_sources: [
                    {
                        provider: { name: "Oura", slug: "oura", logo: "https://logo_url.com" },
                        created_on: "2026-01-06T17:44:21Z",
                        source: { name: "Oura", slug: "oura", logo: "logo_url" },
                    },
                ],
                fallback_time_zone: { id: "Europe/London", source_slug: "manual", updated_at: "2026-01-06T17:44:21Z" },
                fallback_birth_date: { value: "1989-09-12", source_slug: "manual", updated_at: "2026-01-06T17:44:21Z" },
                ingestion_start: "ingestion_start",
                ingestion_end: "ingestion_end",
            },
        ];
        server
            .mockEndpoint()
            .get("/v2/team/users/search")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.team.getUserById({
            queryId: "query_id",
        });
        expect(response).toEqual([
            {
                userId: "56bd81c9-6219-4000-a775-ae85526eba18",
                teamId: "56bd81c9-6219-4000-a775-ae85526eba18",
                clientUserId: "ZTEwZjNjMjctOTI2ZS00M2Vm",
                createdOn: new Date("2026-01-06T17:44:21.000Z"),
                connectedSources: [
                    {
                        provider: {
                            name: "Oura",
                            slug: "oura",
                            logo: "https://logo_url.com",
                        },
                        createdOn: new Date("2026-01-06T17:44:21.000Z"),
                        source: {
                            name: "Oura",
                            slug: "oura",
                            logo: "logo_url",
                        },
                    },
                ],
                fallbackTimeZone: {
                    id: "Europe/London",
                    sourceSlug: "manual",
                    updatedAt: new Date("2026-01-06T17:44:21.000Z"),
                },
                fallbackBirthDate: {
                    value: "1989-09-12",
                    sourceSlug: "manual",
                    updatedAt: new Date("2026-01-06T17:44:21.000Z"),
                },
                ingestionStart: "ingestion_start",
                ingestionEnd: "ingestion_end",
            },
        ]);
    });

    test("get_user_by_id (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/team/users/search")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.team.getUserById();
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("get_svix_url", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v2/team/svix/url").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.team.getSvixUrl();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_source_priorities (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [{ key: "value" }];
        server
            .mockEndpoint()
            .get("/v2/team/source/priorities")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.team.getSourcePriorities({
            dataType: "workouts",
        });
        expect(response).toEqual([
            {
                key: "value",
            },
        ]);
    });

    test("get_source_priorities (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/team/source/priorities")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.team.getSourcePriorities();
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });

    test("update_source_priorities", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [{ key: "value" }];
        server
            .mockEndpoint()
            .patch("/v2/team/source/priorities")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.team.updateSourcePriorities();
        expect(response).toEqual([
            {
                key: "value",
            },
        ]);
    });

    test("get_physicians (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [{ first_name: "first_name", last_name: "last_name", npi: "npi" }];
        server
            .mockEndpoint()
            .get("/v2/team/team_id/physicians")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.team.getPhysicians("team_id");
        expect(response).toEqual([
            {
                firstName: "first_name",
                lastName: "last_name",
                npi: "npi",
            },
        ]);
    });

    test("get_physicians (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new VitalClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/v2/team/team_id/physicians")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.team.getPhysicians("team_id");
        }).rejects.toThrow(Vital.UnprocessableEntityError);
    });
});
