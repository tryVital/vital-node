// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as serializers from "../../../../serialization/index.js";
import * as Vital from "../../../index.js";

export declare namespace VitalsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class VitalsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<VitalsClient.Options>;

    constructor(options: VitalsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWorkoutSwimmingStrokeGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.workoutSwimmingStrokeGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public workoutSwimmingStrokeGrouped(
        user_id: string,
        request: Vital.VitalsWorkoutSwimmingStrokeGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedWorkoutSwimmingStrokeResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__workoutSwimmingStrokeGrouped(user_id, request, requestOptions),
        );
    }

    private async __workoutSwimmingStrokeGrouped(
        user_id: string,
        request: Vital.VitalsWorkoutSwimmingStrokeGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedWorkoutSwimmingStrokeResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/workout_swimming_stroke/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedWorkoutSwimmingStrokeResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/workout_swimming_stroke/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWorkoutDistanceGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.workoutDistanceGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public workoutDistanceGrouped(
        user_id: string,
        request: Vital.VitalsWorkoutDistanceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedWorkoutDistanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__workoutDistanceGrouped(user_id, request, requestOptions));
    }

    private async __workoutDistanceGrouped(
        user_id: string,
        request: Vital.VitalsWorkoutDistanceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedWorkoutDistanceResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/workout_distance/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedWorkoutDistanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/workout_distance/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHeartRateRecoveryOneMinuteGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.heartRateRecoveryOneMinuteGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public heartRateRecoveryOneMinuteGrouped(
        user_id: string,
        request: Vital.VitalsHeartRateRecoveryOneMinuteGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedHeartRateRecoveryOneMinuteResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__heartRateRecoveryOneMinuteGrouped(user_id, request, requestOptions),
        );
    }

    private async __heartRateRecoveryOneMinuteGrouped(
        user_id: string,
        request: Vital.VitalsHeartRateRecoveryOneMinuteGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedHeartRateRecoveryOneMinuteResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/heart_rate_recovery_one_minute/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedHeartRateRecoveryOneMinuteResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/heart_rate_recovery_one_minute/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWaistCircumferenceGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.waistCircumferenceGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public waistCircumferenceGrouped(
        user_id: string,
        request: Vital.VitalsWaistCircumferenceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedWaistCircumferenceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__waistCircumferenceGrouped(user_id, request, requestOptions));
    }

    private async __waistCircumferenceGrouped(
        user_id: string,
        request: Vital.VitalsWaistCircumferenceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedWaistCircumferenceResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/waist_circumference/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedWaistCircumferenceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/waist_circumference/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsLeanBodyMassGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.leanBodyMassGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public leanBodyMassGrouped(
        user_id: string,
        request: Vital.VitalsLeanBodyMassGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedLeanBodyMassResponse> {
        return core.HttpResponsePromise.fromPromise(this.__leanBodyMassGrouped(user_id, request, requestOptions));
    }

    private async __leanBodyMassGrouped(
        user_id: string,
        request: Vital.VitalsLeanBodyMassGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedLeanBodyMassResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/lean_body_mass/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedLeanBodyMassResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/lean_body_mass/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyMassIndexGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyMassIndexGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyMassIndexGrouped(
        user_id: string,
        request: Vital.VitalsBodyMassIndexGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBodyMassIndexResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bodyMassIndexGrouped(user_id, request, requestOptions));
    }

    private async __bodyMassIndexGrouped(
        user_id: string,
        request: Vital.VitalsBodyMassIndexGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBodyMassIndexResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_mass_index/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBodyMassIndexResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_mass_index/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBasalBodyTemperatureGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.basalBodyTemperatureGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public basalBodyTemperatureGrouped(
        user_id: string,
        request: Vital.VitalsBasalBodyTemperatureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBasalBodyTemperatureResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__basalBodyTemperatureGrouped(user_id, request, requestOptions),
        );
    }

    private async __basalBodyTemperatureGrouped(
        user_id: string,
        request: Vital.VitalsBasalBodyTemperatureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBasalBodyTemperatureResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/basal_body_temperature/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBasalBodyTemperatureResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/basal_body_temperature/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHandwashingGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.handwashingGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public handwashingGrouped(
        user_id: string,
        request: Vital.VitalsHandwashingGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedHandwashingResponse> {
        return core.HttpResponsePromise.fromPromise(this.__handwashingGrouped(user_id, request, requestOptions));
    }

    private async __handwashingGrouped(
        user_id: string,
        request: Vital.VitalsHandwashingGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedHandwashingResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/handwashing/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedHandwashingResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/handwashing/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsDaylightExposureGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.daylightExposureGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public daylightExposureGrouped(
        user_id: string,
        request: Vital.VitalsDaylightExposureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedDaylightExposureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__daylightExposureGrouped(user_id, request, requestOptions));
    }

    private async __daylightExposureGrouped(
        user_id: string,
        request: Vital.VitalsDaylightExposureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedDaylightExposureResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/daylight_exposure/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedDaylightExposureResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/daylight_exposure/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsUvExposureGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.uvExposureGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public uvExposureGrouped(
        user_id: string,
        request: Vital.VitalsUvExposureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedUvExposureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__uvExposureGrouped(user_id, request, requestOptions));
    }

    private async __uvExposureGrouped(
        user_id: string,
        request: Vital.VitalsUvExposureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedUvExposureResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/uv_exposure/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedUvExposureResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/uv_exposure/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsFallGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.fallGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public fallGrouped(
        user_id: string,
        request: Vital.VitalsFallGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedFallResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fallGrouped(user_id, request, requestOptions));
    }

    private async __fallGrouped(
        user_id: string,
        request: Vital.VitalsFallGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedFallResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/fall/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedFallResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/fall/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsInhalerUsageGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.inhalerUsageGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public inhalerUsageGrouped(
        user_id: string,
        request: Vital.VitalsInhalerUsageGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedInhalerUsageResponse> {
        return core.HttpResponsePromise.fromPromise(this.__inhalerUsageGrouped(user_id, request, requestOptions));
    }

    private async __inhalerUsageGrouped(
        user_id: string,
        request: Vital.VitalsInhalerUsageGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedInhalerUsageResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/inhaler_usage/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedInhalerUsageResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/inhaler_usage/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsPeakExpiratoryFlowRateGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.peakExpiratoryFlowRateGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public peakExpiratoryFlowRateGrouped(
        user_id: string,
        request: Vital.VitalsPeakExpiratoryFlowRateGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedPeakExpiratoryFlowRateResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__peakExpiratoryFlowRateGrouped(user_id, request, requestOptions),
        );
    }

    private async __peakExpiratoryFlowRateGrouped(
        user_id: string,
        request: Vital.VitalsPeakExpiratoryFlowRateGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedPeakExpiratoryFlowRateResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/peak_expiratory_flow_rate/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedPeakExpiratoryFlowRateResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/peak_expiratory_flow_rate/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsForcedVitalCapacityGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.forcedVitalCapacityGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public forcedVitalCapacityGrouped(
        user_id: string,
        request: Vital.VitalsForcedVitalCapacityGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedForcedVitalCapacityResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__forcedVitalCapacityGrouped(user_id, request, requestOptions),
        );
    }

    private async __forcedVitalCapacityGrouped(
        user_id: string,
        request: Vital.VitalsForcedVitalCapacityGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedForcedVitalCapacityResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/forced_vital_capacity/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedForcedVitalCapacityResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/forced_vital_capacity/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsForcedExpiratoryVolume1GroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.forcedExpiratoryVolume1Grouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public forcedExpiratoryVolume1Grouped(
        user_id: string,
        request: Vital.VitalsForcedExpiratoryVolume1GroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedForcedExpiratoryVolume1Response> {
        return core.HttpResponsePromise.fromPromise(
            this.__forcedExpiratoryVolume1Grouped(user_id, request, requestOptions),
        );
    }

    private async __forcedExpiratoryVolume1Grouped(
        user_id: string,
        request: Vital.VitalsForcedExpiratoryVolume1GroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedForcedExpiratoryVolume1Response>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/forced_expiratory_volume_1/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedForcedExpiratoryVolume1Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/forced_expiratory_volume_1/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWheelchairPushGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.wheelchairPushGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public wheelchairPushGrouped(
        user_id: string,
        request: Vital.VitalsWheelchairPushGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedWheelchairPushResponse> {
        return core.HttpResponsePromise.fromPromise(this.__wheelchairPushGrouped(user_id, request, requestOptions));
    }

    private async __wheelchairPushGrouped(
        user_id: string,
        request: Vital.VitalsWheelchairPushGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedWheelchairPushResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/wheelchair_push/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedWheelchairPushResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/wheelchair_push/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsSleepBreathingDisturbanceGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.sleepBreathingDisturbanceGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public sleepBreathingDisturbanceGrouped(
        user_id: string,
        request: Vital.VitalsSleepBreathingDisturbanceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedSleepBreathingDisturbanceResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__sleepBreathingDisturbanceGrouped(user_id, request, requestOptions),
        );
    }

    private async __sleepBreathingDisturbanceGrouped(
        user_id: string,
        request: Vital.VitalsSleepBreathingDisturbanceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedSleepBreathingDisturbanceResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/sleep_breathing_disturbance/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedSleepBreathingDisturbanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/sleep_breathing_disturbance/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsSleepApneaAlertGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.sleepApneaAlertGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public sleepApneaAlertGrouped(
        user_id: string,
        request: Vital.VitalsSleepApneaAlertGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedSleepApneaAlertResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sleepApneaAlertGrouped(user_id, request, requestOptions));
    }

    private async __sleepApneaAlertGrouped(
        user_id: string,
        request: Vital.VitalsSleepApneaAlertGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedSleepApneaAlertResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/sleep_apnea_alert/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedSleepApneaAlertResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/sleep_apnea_alert/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsStandDurationGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.standDurationGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public standDurationGrouped(
        user_id: string,
        request: Vital.VitalsStandDurationGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedStandDurationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__standDurationGrouped(user_id, request, requestOptions));
    }

    private async __standDurationGrouped(
        user_id: string,
        request: Vital.VitalsStandDurationGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedStandDurationResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/stand_duration/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedStandDurationResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/stand_duration/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsStandHourGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.standHourGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public standHourGrouped(
        user_id: string,
        request: Vital.VitalsStandHourGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedStandHourResponse> {
        return core.HttpResponsePromise.fromPromise(this.__standHourGrouped(user_id, request, requestOptions));
    }

    private async __standHourGrouped(
        user_id: string,
        request: Vital.VitalsStandHourGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedStandHourResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/stand_hour/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedStandHourResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/stand_hour/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHeartRateAlertGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.heartRateAlertGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public heartRateAlertGrouped(
        user_id: string,
        request: Vital.VitalsHeartRateAlertGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedHeartRateAlertResponse> {
        return core.HttpResponsePromise.fromPromise(this.__heartRateAlertGrouped(user_id, request, requestOptions));
    }

    private async __heartRateAlertGrouped(
        user_id: string,
        request: Vital.VitalsHeartRateAlertGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedHeartRateAlertResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/heart_rate_alert/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedHeartRateAlertResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/heart_rate_alert/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsAfibBurdenGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.afibBurdenGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public afibBurdenGrouped(
        user_id: string,
        request: Vital.VitalsAfibBurdenGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedAFibBurdenResponse> {
        return core.HttpResponsePromise.fromPromise(this.__afibBurdenGrouped(user_id, request, requestOptions));
    }

    private async __afibBurdenGrouped(
        user_id: string,
        request: Vital.VitalsAfibBurdenGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedAFibBurdenResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/afib_burden/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedAFibBurdenResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/afib_burden/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWorkoutDurationGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.workoutDurationGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public workoutDurationGrouped(
        user_id: string,
        request: Vital.VitalsWorkoutDurationGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedWorkoutDurationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__workoutDurationGrouped(user_id, request, requestOptions));
    }

    private async __workoutDurationGrouped(
        user_id: string,
        request: Vital.VitalsWorkoutDurationGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedWorkoutDurationResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/workout_duration/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedWorkoutDurationResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/workout_duration/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsVo2MaxGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.vo2MaxGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public vo2MaxGrouped(
        user_id: string,
        request: Vital.VitalsVo2MaxGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedVo2MaxResponse> {
        return core.HttpResponsePromise.fromPromise(this.__vo2MaxGrouped(user_id, request, requestOptions));
    }

    private async __vo2MaxGrouped(
        user_id: string,
        request: Vital.VitalsVo2MaxGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedVo2MaxResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/vo2_max/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedVo2MaxResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/vo2_max/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsStressLevelGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.stressLevelGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public stressLevelGrouped(
        user_id: string,
        request: Vital.VitalsStressLevelGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedStressLevelResponse> {
        return core.HttpResponsePromise.fromPromise(this.__stressLevelGrouped(user_id, request, requestOptions));
    }

    private async __stressLevelGrouped(
        user_id: string,
        request: Vital.VitalsStressLevelGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedStressLevelResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/stress_level/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedStressLevelResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/stress_level/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsMindfulnessMinutesGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.mindfulnessMinutesGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public mindfulnessMinutesGrouped(
        user_id: string,
        request: Vital.VitalsMindfulnessMinutesGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedMindfulnessMinutesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__mindfulnessMinutesGrouped(user_id, request, requestOptions));
    }

    private async __mindfulnessMinutesGrouped(
        user_id: string,
        request: Vital.VitalsMindfulnessMinutesGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedMindfulnessMinutesResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/mindfulness_minutes/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedMindfulnessMinutesResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/mindfulness_minutes/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCaffeineGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.caffeineGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public caffeineGrouped(
        user_id: string,
        request: Vital.VitalsCaffeineGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedCaffeineResponse> {
        return core.HttpResponsePromise.fromPromise(this.__caffeineGrouped(user_id, request, requestOptions));
    }

    private async __caffeineGrouped(
        user_id: string,
        request: Vital.VitalsCaffeineGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedCaffeineResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/caffeine/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedCaffeineResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/caffeine/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWaterGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.waterGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public waterGrouped(
        user_id: string,
        request: Vital.VitalsWaterGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedWaterResponse> {
        return core.HttpResponsePromise.fromPromise(this.__waterGrouped(user_id, request, requestOptions));
    }

    private async __waterGrouped(
        user_id: string,
        request: Vital.VitalsWaterGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedWaterResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/water/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedWaterResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/water/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsStepsGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.stepsGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public stepsGrouped(
        user_id: string,
        request: Vital.VitalsStepsGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedStepsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__stepsGrouped(user_id, request, requestOptions));
    }

    private async __stepsGrouped(
        user_id: string,
        request: Vital.VitalsStepsGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedStepsResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/steps/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedStepsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/steps/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsFloorsClimbedGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.floorsClimbedGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public floorsClimbedGrouped(
        user_id: string,
        request: Vital.VitalsFloorsClimbedGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedFloorsClimbedResponse> {
        return core.HttpResponsePromise.fromPromise(this.__floorsClimbedGrouped(user_id, request, requestOptions));
    }

    private async __floorsClimbedGrouped(
        user_id: string,
        request: Vital.VitalsFloorsClimbedGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedFloorsClimbedResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/floors_climbed/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedFloorsClimbedResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/floors_climbed/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsDistanceGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.distanceGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public distanceGrouped(
        user_id: string,
        request: Vital.VitalsDistanceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedDistanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__distanceGrouped(user_id, request, requestOptions));
    }

    private async __distanceGrouped(
        user_id: string,
        request: Vital.VitalsDistanceGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedDistanceResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/distance/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedDistanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/distance/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCaloriesBasalGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.caloriesBasalGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public caloriesBasalGrouped(
        user_id: string,
        request: Vital.VitalsCaloriesBasalGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedCaloriesBasalResponse> {
        return core.HttpResponsePromise.fromPromise(this.__caloriesBasalGrouped(user_id, request, requestOptions));
    }

    private async __caloriesBasalGrouped(
        user_id: string,
        request: Vital.VitalsCaloriesBasalGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedCaloriesBasalResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/calories_basal/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedCaloriesBasalResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/calories_basal/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCaloriesActiveGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.caloriesActiveGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public caloriesActiveGrouped(
        user_id: string,
        request: Vital.VitalsCaloriesActiveGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedCaloriesActiveResponse> {
        return core.HttpResponsePromise.fromPromise(this.__caloriesActiveGrouped(user_id, request, requestOptions));
    }

    private async __caloriesActiveGrouped(
        user_id: string,
        request: Vital.VitalsCaloriesActiveGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedCaloriesActiveResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/calories_active/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedCaloriesActiveResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/calories_active/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsRespiratoryRateGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.respiratoryRateGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public respiratoryRateGrouped(
        user_id: string,
        request: Vital.VitalsRespiratoryRateGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedRespiratoryRateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__respiratoryRateGrouped(user_id, request, requestOptions));
    }

    private async __respiratoryRateGrouped(
        user_id: string,
        request: Vital.VitalsRespiratoryRateGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedRespiratoryRateResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/respiratory_rate/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedRespiratoryRateResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/respiratory_rate/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsNoteGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.noteGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public noteGrouped(
        user_id: string,
        request: Vital.VitalsNoteGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedNoteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__noteGrouped(user_id, request, requestOptions));
    }

    private async __noteGrouped(
        user_id: string,
        request: Vital.VitalsNoteGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedNoteResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/note/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedNoteResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/note/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsInsulinInjectionGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.insulinInjectionGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public insulinInjectionGrouped(
        user_id: string,
        request: Vital.VitalsInsulinInjectionGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedInsulinInjectionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__insulinInjectionGrouped(user_id, request, requestOptions));
    }

    private async __insulinInjectionGrouped(
        user_id: string,
        request: Vital.VitalsInsulinInjectionGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedInsulinInjectionResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/insulin_injection/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedInsulinInjectionResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/insulin_injection/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsIgeGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.igeGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public igeGrouped(
        user_id: string,
        request: Vital.VitalsIgeGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedIgeResponse> {
        return core.HttpResponsePromise.fromPromise(this.__igeGrouped(user_id, request, requestOptions));
    }

    private async __igeGrouped(
        user_id: string,
        request: Vital.VitalsIgeGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedIgeResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/ige/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedIgeResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/ige/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsIggGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.iggGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public iggGrouped(
        user_id: string,
        request: Vital.VitalsIggGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedIggResponse> {
        return core.HttpResponsePromise.fromPromise(this.__iggGrouped(user_id, request, requestOptions));
    }

    private async __iggGrouped(
        user_id: string,
        request: Vital.VitalsIggGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedIggResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/igg/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedIggResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/igg/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHypnogramGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.hypnogramGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public hypnogramGrouped(
        user_id: string,
        request: Vital.VitalsHypnogramGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedHypnogramResponse> {
        return core.HttpResponsePromise.fromPromise(this.__hypnogramGrouped(user_id, request, requestOptions));
    }

    private async __hypnogramGrouped(
        user_id: string,
        request: Vital.VitalsHypnogramGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedHypnogramResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/hypnogram/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedHypnogramResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/hypnogram/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHrvGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.hrvGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public hrvGrouped(
        user_id: string,
        request: Vital.VitalsHrvGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedHrvResponse> {
        return core.HttpResponsePromise.fromPromise(this.__hrvGrouped(user_id, request, requestOptions));
    }

    private async __hrvGrouped(
        user_id: string,
        request: Vital.VitalsHrvGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedHrvResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/hrv/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedHrvResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/hrv/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHeartrateGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.heartrateGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public heartrateGrouped(
        user_id: string,
        request: Vital.VitalsHeartrateGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedHeartRateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__heartrateGrouped(user_id, request, requestOptions));
    }

    private async __heartrateGrouped(
        user_id: string,
        request: Vital.VitalsHeartrateGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedHeartRateResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/heartrate/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedHeartRateResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/heartrate/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsGlucoseGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.glucoseGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public glucoseGrouped(
        user_id: string,
        request: Vital.VitalsGlucoseGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedGlucoseResponse> {
        return core.HttpResponsePromise.fromPromise(this.__glucoseGrouped(user_id, request, requestOptions));
    }

    private async __glucoseGrouped(
        user_id: string,
        request: Vital.VitalsGlucoseGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedGlucoseResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/glucose/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedGlucoseResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/glucose/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCholesterolGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.cholesterolGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public cholesterolGrouped(
        user_id: string,
        request: Vital.VitalsCholesterolGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedCholesterolResponse> {
        return core.HttpResponsePromise.fromPromise(this.__cholesterolGrouped(user_id, request, requestOptions));
    }

    private async __cholesterolGrouped(
        user_id: string,
        request: Vital.VitalsCholesterolGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedCholesterolResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/cholesterol/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedCholesterolResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/cholesterol/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCarbohydratesGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.carbohydratesGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public carbohydratesGrouped(
        user_id: string,
        request: Vital.VitalsCarbohydratesGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedCarbohydratesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__carbohydratesGrouped(user_id, request, requestOptions));
    }

    private async __carbohydratesGrouped(
        user_id: string,
        request: Vital.VitalsCarbohydratesGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedCarbohydratesResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/carbohydrates/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedCarbohydratesResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/carbohydrates/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyTemperatureDeltaGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyTemperatureDeltaGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyTemperatureDeltaGrouped(
        user_id: string,
        request: Vital.VitalsBodyTemperatureDeltaGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBodyTemperatureDeltaResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__bodyTemperatureDeltaGrouped(user_id, request, requestOptions),
        );
    }

    private async __bodyTemperatureDeltaGrouped(
        user_id: string,
        request: Vital.VitalsBodyTemperatureDeltaGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBodyTemperatureDeltaResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_temperature_delta/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBodyTemperatureDeltaResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_temperature_delta/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyTemperatureGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyTemperatureGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyTemperatureGrouped(
        user_id: string,
        request: Vital.VitalsBodyTemperatureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBodyTemperatureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bodyTemperatureGrouped(user_id, request, requestOptions));
    }

    private async __bodyTemperatureGrouped(
        user_id: string,
        request: Vital.VitalsBodyTemperatureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBodyTemperatureResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_temperature/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBodyTemperatureResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_temperature/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyWeightGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyWeightGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyWeightGrouped(
        user_id: string,
        request: Vital.VitalsBodyWeightGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBodyWeightResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bodyWeightGrouped(user_id, request, requestOptions));
    }

    private async __bodyWeightGrouped(
        user_id: string,
        request: Vital.VitalsBodyWeightGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBodyWeightResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_weight/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBodyWeightResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_weight/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyFatGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyFatGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyFatGrouped(
        user_id: string,
        request: Vital.VitalsBodyFatGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBodyFatResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bodyFatGrouped(user_id, request, requestOptions));
    }

    private async __bodyFatGrouped(
        user_id: string,
        request: Vital.VitalsBodyFatGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBodyFatResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_fat/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBodyFatResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_fat/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBloodOxygenGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bloodOxygenGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bloodOxygenGrouped(
        user_id: string,
        request: Vital.VitalsBloodOxygenGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBloodOxygenResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bloodOxygenGrouped(user_id, request, requestOptions));
    }

    private async __bloodOxygenGrouped(
        user_id: string,
        request: Vital.VitalsBloodOxygenGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBloodOxygenResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/blood_oxygen/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBloodOxygenResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/blood_oxygen/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsElectrocardiogramVoltageGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.electrocardiogramVoltageGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public electrocardiogramVoltageGrouped(
        user_id: string,
        request: Vital.VitalsElectrocardiogramVoltageGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedElectrocardiogramVoltageResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__electrocardiogramVoltageGrouped(user_id, request, requestOptions),
        );
    }

    private async __electrocardiogramVoltageGrouped(
        user_id: string,
        request: Vital.VitalsElectrocardiogramVoltageGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedElectrocardiogramVoltageResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/electrocardiogram_voltage/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedElectrocardiogramVoltageResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/electrocardiogram_voltage/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBloodPressureGroupedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bloodPressureGrouped("user_id", {
     *         cursor: "cursor",
     *         nextCursor: "next_cursor",
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bloodPressureGrouped(
        user_id: string,
        request: Vital.VitalsBloodPressureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GroupedBloodPressureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bloodPressureGrouped(user_id, request, requestOptions));
    }

    private async __bloodPressureGrouped(
        user_id: string,
        request: Vital.VitalsBloodPressureGroupedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GroupedBloodPressureResponse>> {
        const { cursor, nextCursor, provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/blood_pressure/grouped`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GroupedBloodPressureResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/blood_pressure/grouped",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsVo2MaxRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.vo2Max("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public vo2Max(
        user_id: string,
        request: Vital.VitalsVo2MaxRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingVo2MaxTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__vo2Max(user_id, request, requestOptions));
    }

    private async __vo2Max(
        user_id: string,
        request: Vital.VitalsVo2MaxRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingVo2MaxTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/vo2_max`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.vo2Max.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/vo2_max",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsStressLevelRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.stressLevel("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public stressLevel(
        user_id: string,
        request: Vital.VitalsStressLevelRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingStressLevelTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__stressLevel(user_id, request, requestOptions));
    }

    private async __stressLevel(
        user_id: string,
        request: Vital.VitalsStressLevelRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingStressLevelTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/stress_level`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.stressLevel.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/stress_level",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsMindfulnessMinutesRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.mindfulnessMinutes("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public mindfulnessMinutes(
        user_id: string,
        request: Vital.VitalsMindfulnessMinutesRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingMindfulnessMinutesTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__mindfulnessMinutes(user_id, request, requestOptions));
    }

    private async __mindfulnessMinutes(
        user_id: string,
        request: Vital.VitalsMindfulnessMinutesRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingMindfulnessMinutesTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/mindfulness_minutes`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.mindfulnessMinutes.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/mindfulness_minutes",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCaffeineRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.caffeine("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public caffeine(
        user_id: string,
        request: Vital.VitalsCaffeineRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCaffeineTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__caffeine(user_id, request, requestOptions));
    }

    private async __caffeine(
        user_id: string,
        request: Vital.VitalsCaffeineRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCaffeineTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/caffeine`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.caffeine.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/caffeine",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsWaterRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.water("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public water(
        user_id: string,
        request: Vital.VitalsWaterRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingWaterTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__water(user_id, request, requestOptions));
    }

    private async __water(
        user_id: string,
        request: Vital.VitalsWaterRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingWaterTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/water`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.water.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/water",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsStepsRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.steps("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public steps(
        user_id: string,
        request: Vital.VitalsStepsRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingStepsTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__steps(user_id, request, requestOptions));
    }

    private async __steps(
        user_id: string,
        request: Vital.VitalsStepsRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingStepsTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/steps`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.steps.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/steps",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsFloorsClimbedRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.floorsClimbed("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public floorsClimbed(
        user_id: string,
        request: Vital.VitalsFloorsClimbedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingFloorsClimbedTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__floorsClimbed(user_id, request, requestOptions));
    }

    private async __floorsClimbed(
        user_id: string,
        request: Vital.VitalsFloorsClimbedRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingFloorsClimbedTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/floors_climbed`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.floorsClimbed.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/floors_climbed",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsDistanceRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.distance("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public distance(
        user_id: string,
        request: Vital.VitalsDistanceRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingDistanceTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__distance(user_id, request, requestOptions));
    }

    private async __distance(
        user_id: string,
        request: Vital.VitalsDistanceRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingDistanceTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/distance`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.distance.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/distance",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCaloriesBasalRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.caloriesBasal("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public caloriesBasal(
        user_id: string,
        request: Vital.VitalsCaloriesBasalRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCaloriesBasalTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__caloriesBasal(user_id, request, requestOptions));
    }

    private async __caloriesBasal(
        user_id: string,
        request: Vital.VitalsCaloriesBasalRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCaloriesBasalTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/calories_basal`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.caloriesBasal.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/calories_basal",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCaloriesActiveRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.caloriesActive("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public caloriesActive(
        user_id: string,
        request: Vital.VitalsCaloriesActiveRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCaloriesActiveTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__caloriesActive(user_id, request, requestOptions));
    }

    private async __caloriesActive(
        user_id: string,
        request: Vital.VitalsCaloriesActiveRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCaloriesActiveTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/calories_active`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.caloriesActive.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/calories_active",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsRespiratoryRateRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.respiratoryRate("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public respiratoryRate(
        user_id: string,
        request: Vital.VitalsRespiratoryRateRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingRespiratoryRateTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__respiratoryRate(user_id, request, requestOptions));
    }

    private async __respiratoryRate(
        user_id: string,
        request: Vital.VitalsRespiratoryRateRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingRespiratoryRateTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/respiratory_rate`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.respiratoryRate.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/respiratory_rate",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsIgeRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.ige("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public ige(
        user_id: string,
        request: Vital.VitalsIgeRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingIgeTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__ige(user_id, request, requestOptions));
    }

    private async __ige(
        user_id: string,
        request: Vital.VitalsIgeRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingIgeTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/ige`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.ige.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/timeseries/{user_id}/ige");
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsIggRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.igg("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public igg(
        user_id: string,
        request: Vital.VitalsIggRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingIggTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__igg(user_id, request, requestOptions));
    }

    private async __igg(
        user_id: string,
        request: Vital.VitalsIggRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingIggTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/igg`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.igg.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/timeseries/{user_id}/igg");
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHypnogramRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.hypnogram("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public hypnogram(
        user_id: string,
        request: Vital.VitalsHypnogramRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingHypnogramTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__hypnogram(user_id, request, requestOptions));
    }

    private async __hypnogram(
        user_id: string,
        request: Vital.VitalsHypnogramRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingHypnogramTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/hypnogram`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.hypnogram.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/hypnogram",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHrvRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.hrv("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public hrv(
        user_id: string,
        request: Vital.VitalsHrvRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingHrvTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__hrv(user_id, request, requestOptions));
    }

    private async __hrv(
        user_id: string,
        request: Vital.VitalsHrvRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingHrvTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/hrv`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.hrv.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/timeseries/{user_id}/hrv");
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsHeartrateRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.heartrate("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public heartrate(
        user_id: string,
        request: Vital.VitalsHeartrateRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingHeartRateTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__heartrate(user_id, request, requestOptions));
    }

    private async __heartrate(
        user_id: string,
        request: Vital.VitalsHeartrateRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingHeartRateTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/heartrate`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.heartrate.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/heartrate",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsGlucoseRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.glucose("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public glucose(
        user_id: string,
        request: Vital.VitalsGlucoseRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingGlucoseTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__glucose(user_id, request, requestOptions));
    }

    private async __glucose(
        user_id: string,
        request: Vital.VitalsGlucoseRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingGlucoseTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/glucose`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.glucose.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/glucose",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCholesterolTriglyceridesRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.cholesterolTriglycerides("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public cholesterolTriglycerides(
        user_id: string,
        request: Vital.VitalsCholesterolTriglyceridesRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCholesterolTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__cholesterolTriglycerides(user_id, request, requestOptions));
    }

    private async __cholesterolTriglycerides(
        user_id: string,
        request: Vital.VitalsCholesterolTriglyceridesRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCholesterolTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/cholesterol/triglycerides`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.cholesterolTriglycerides.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/cholesterol/triglycerides",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCholesterolTotalRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.cholesterolTotal("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public cholesterolTotal(
        user_id: string,
        request: Vital.VitalsCholesterolTotalRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCholesterolTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__cholesterolTotal(user_id, request, requestOptions));
    }

    private async __cholesterolTotal(
        user_id: string,
        request: Vital.VitalsCholesterolTotalRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCholesterolTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/cholesterol/total`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.cholesterolTotal.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/cholesterol/total",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCholesterolLdlRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.cholesterolLdl("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public cholesterolLdl(
        user_id: string,
        request: Vital.VitalsCholesterolLdlRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCholesterolTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__cholesterolLdl(user_id, request, requestOptions));
    }

    private async __cholesterolLdl(
        user_id: string,
        request: Vital.VitalsCholesterolLdlRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCholesterolTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/cholesterol/ldl`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.cholesterolLdl.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/cholesterol/ldl",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCholesterolHdlRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.cholesterolHdl("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public cholesterolHdl(
        user_id: string,
        request: Vital.VitalsCholesterolHdlRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCholesterolTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__cholesterolHdl(user_id, request, requestOptions));
    }

    private async __cholesterolHdl(
        user_id: string,
        request: Vital.VitalsCholesterolHdlRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCholesterolTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/cholesterol/hdl`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.cholesterolHdl.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/cholesterol/hdl",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsCholesterolRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.cholesterol("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public cholesterol(
        user_id: string,
        request: Vital.VitalsCholesterolRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingCholesterolTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__cholesterol(user_id, request, requestOptions));
    }

    private async __cholesterol(
        user_id: string,
        request: Vital.VitalsCholesterolRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingCholesterolTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/cholesterol`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.cholesterol.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/cholesterol",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyWeightRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyWeight("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyWeight(
        user_id: string,
        request: Vital.VitalsBodyWeightRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingBodyWeightTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__bodyWeight(user_id, request, requestOptions));
    }

    private async __bodyWeight(
        user_id: string,
        request: Vital.VitalsBodyWeightRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingBodyWeightTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_weight`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.bodyWeight.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_weight",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBodyFatRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bodyFat("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bodyFat(
        user_id: string,
        request: Vital.VitalsBodyFatRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingBodyFatTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__bodyFat(user_id, request, requestOptions));
    }

    private async __bodyFat(
        user_id: string,
        request: Vital.VitalsBodyFatRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingBodyFatTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/body_fat`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.bodyFat.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/body_fat",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBloodOxygenRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bloodOxygen("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bloodOxygen(
        user_id: string,
        request: Vital.VitalsBloodOxygenRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingBloodOxygenTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__bloodOxygen(user_id, request, requestOptions));
    }

    private async __bloodOxygen(
        user_id: string,
        request: Vital.VitalsBloodOxygenRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingBloodOxygenTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/blood_oxygen`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.bloodOxygen.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/blood_oxygen",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsElectrocardiogramVoltageRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.electrocardiogramVoltage("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public electrocardiogramVoltage(
        user_id: string,
        request: Vital.VitalsElectrocardiogramVoltageRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingElectrocardiogramVoltageTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__electrocardiogramVoltage(user_id, request, requestOptions));
    }

    private async __electrocardiogramVoltage(
        user_id: string,
        request: Vital.VitalsElectrocardiogramVoltageRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingElectrocardiogramVoltageTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/electrocardiogram_voltage`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.electrocardiogramVoltage.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/electrocardiogram_voltage",
        );
    }

    /**
     * @param {string} user_id
     * @param {Vital.VitalsBloodPressureRequest} request
     * @param {VitalsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.vitals.bloodPressure("user_id", {
     *         provider: "provider",
     *         startDate: "start_date",
     *         endDate: "end_date"
     *     })
     */
    public bloodPressure(
        user_id: string,
        request: Vital.VitalsBloodPressureRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingBloodPressureTimeseries[]> {
        return core.HttpResponsePromise.fromPromise(this.__bloodPressure(user_id, request, requestOptions));
    }

    private async __bloodPressure(
        user_id: string,
        request: Vital.VitalsBloodPressureRequest,
        requestOptions?: VitalsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingBloodPressureTimeseries[]>> {
        const { provider, startDate, endDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (provider != null) {
            _queryParams.provider = provider;
        }

        _queryParams.start_date = startDate;
        if (endDate != null) {
            _queryParams.end_date = endDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v2/timeseries/${core.url.encodePathParam(user_id)}/blood_pressure`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.vitals.bloodPressure.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/timeseries/{user_id}/blood_pressure",
        );
    }
}
