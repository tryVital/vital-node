// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as serializers from "../../../../serialization/index.js";
import * as Vital from "../../../index.js";

export declare namespace LabTestsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class LabTestsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<LabTestsClient.Options>;

    constructor(options: LabTestsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * GET all the lab tests the team has access to.
     *
     * @param {Vital.LabTestsGetRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.get({
     *         generationMethod: "auto",
     *         labSlug: "lab_slug",
     *         collectionMethod: "testkit",
     *         status: "active",
     *         name: "name",
     *         orderKey: "price",
     *         orderDirection: "asc"
     *     })
     */
    public get(
        request: Vital.LabTestsGetRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingLabTest[]> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: Vital.LabTestsGetRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingLabTest[]>> {
        const {
            generationMethod,
            labSlug,
            collectionMethod,
            status,
            markerIds,
            providerIds,
            name,
            orderKey,
            orderDirection,
        } = request;
        const _queryParams: Record<string, unknown> = {};
        if (generationMethod != null) {
            _queryParams.generation_method = serializers.LabTestGenerationMethodFilter.jsonOrThrow(generationMethod, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (labSlug != null) {
            _queryParams.lab_slug = labSlug;
        }

        if (collectionMethod != null) {
            _queryParams.collection_method = serializers.LabTestCollectionMethod.jsonOrThrow(collectionMethod, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (status != null) {
            _queryParams.status = serializers.LabTestStatus.jsonOrThrow(status, { unrecognizedObjectKeys: "strip" });
        }

        if (markerIds != null) {
            if (Array.isArray(markerIds)) {
                _queryParams.marker_ids = markerIds.map((item) => item.toString());
            } else {
                _queryParams.marker_ids = markerIds;
            }
        }

        if (providerIds != null) {
            if (Array.isArray(providerIds)) {
                _queryParams.provider_ids = providerIds.map((item) => item);
            } else {
                _queryParams.provider_ids = providerIds;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (orderKey != null) {
            _queryParams.order_key = serializers.LabTestsGetRequestOrderKey.jsonOrThrow(orderKey, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (orderDirection != null) {
            _queryParams.order_direction = serializers.LabTestsGetRequestOrderDirection.jsonOrThrow(orderDirection, {
                unrecognizedObjectKeys: "strip",
            });
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/lab_tests",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.labTests.get.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/lab_tests");
    }

    /**
     * @param {Vital.CreateLabTestRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.create({
     *         name: "name",
     *         method: "testkit",
     *         description: "description"
     *     })
     */
    public create(
        request: Vital.CreateLabTestRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingLabTest> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Vital.CreateLabTestRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingLabTest>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/lab_tests",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.CreateLabTestRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingLabTest.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v3/lab_tests");
    }

    /**
     * GET all the lab tests the team has access to.
     *
     * @param {string} lab_test_id
     * @param {Vital.LabTestsGetByIdRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getById("lab_test_id", {
     *         labAccountId: "lab_account_id"
     *     })
     */
    public getById(
        lab_test_id: string,
        request: Vital.LabTestsGetByIdRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingLabTest> {
        return core.HttpResponsePromise.fromPromise(this.__getById(lab_test_id, request, requestOptions));
    }

    private async __getById(
        lab_test_id: string,
        request: Vital.LabTestsGetByIdRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingLabTest>> {
        const { labAccountId } = request;
        const _queryParams: Record<string, unknown> = {};
        if (labAccountId != null) {
            _queryParams.lab_account_id = labAccountId;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/lab_tests/${core.url.encodePathParam(lab_test_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingLabTest.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/lab_tests/{lab_test_id}");
    }

    /**
     * @param {string} lab_test_id
     * @param {Vital.UpdateLabTestRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.updateLabTest("lab_test_id")
     */
    public updateLabTest(
        lab_test_id: string,
        request: Vital.UpdateLabTestRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingLabTest> {
        return core.HttpResponsePromise.fromPromise(this.__updateLabTest(lab_test_id, request, requestOptions));
    }

    private async __updateLabTest(
        lab_test_id: string,
        request: Vital.UpdateLabTestRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingLabTest>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/lab_tests/${core.url.encodePathParam(lab_test_id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.UpdateLabTestRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingLabTest.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/v3/lab_tests/{lab_test_id}");
    }

    /**
     * GET all the markers for the given lab.
     *
     * @param {Vital.LabTestsGetMarkersRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getMarkers({
     *         name: "name",
     *         aLaCarteEnabled: true,
     *         labAccountId: "lab_account_id",
     *         page: 1,
     *         size: 1
     *     })
     */
    public getMarkers(
        request: Vital.LabTestsGetMarkersRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GetMarkersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getMarkers(request, requestOptions));
    }

    private async __getMarkers(
        request: Vital.LabTestsGetMarkersRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GetMarkersResponse>> {
        const { labId, name, aLaCarteEnabled, labAccountId, page, size } = request;
        const _queryParams: Record<string, unknown> = {};
        if (labId != null) {
            if (Array.isArray(labId)) {
                _queryParams.lab_id = labId.map((item) => item.toString());
            } else {
                _queryParams.lab_id = labId;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (aLaCarteEnabled != null) {
            _queryParams.a_la_carte_enabled = aLaCarteEnabled;
        }

        if (labAccountId != null) {
            _queryParams.lab_account_id = labAccountId;
        }

        if (page != null) {
            _queryParams.page = page;
        }

        if (size != null) {
            _queryParams.size = size;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/lab_tests/markers",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GetMarkersResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/lab_tests/markers");
    }

    /**
     * @param {Vital.LabTestsGetMarkersForOrderSetRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getMarkersForOrderSet({
     *         page: 1,
     *         size: 1,
     *         body: {}
     *     })
     */
    public getMarkersForOrderSet(
        request: Vital.LabTestsGetMarkersForOrderSetRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GetMarkersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getMarkersForOrderSet(request, requestOptions));
    }

    private async __getMarkersForOrderSet(
        request: Vital.LabTestsGetMarkersForOrderSetRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GetMarkersResponse>> {
        const { page, size, body: _body } = request;
        const _queryParams: Record<string, unknown> = {};
        if (page != null) {
            _queryParams.page = page;
        }

        if (size != null) {
            _queryParams.size = size;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/lab_tests/list_order_set_markers",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.OrderSetRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GetMarkersResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/lab_tests/list_order_set_markers",
        );
    }

    /**
     * @param {string} lab_test_id
     * @param {Vital.LabTestsGetMarkersForLabTestRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getMarkersForLabTest("lab_test_id", {
     *         labAccountId: "lab_account_id",
     *         page: 1,
     *         size: 1
     *     })
     */
    public getMarkersForLabTest(
        lab_test_id: string,
        request: Vital.LabTestsGetMarkersForLabTestRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GetMarkersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getMarkersForLabTest(lab_test_id, request, requestOptions));
    }

    private async __getMarkersForLabTest(
        lab_test_id: string,
        request: Vital.LabTestsGetMarkersForLabTestRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GetMarkersResponse>> {
        const { labAccountId, page, size } = request;
        const _queryParams: Record<string, unknown> = {};
        if (labAccountId != null) {
            _queryParams.lab_account_id = labAccountId;
        }

        if (page != null) {
            _queryParams.page = page;
        }

        if (size != null) {
            _queryParams.size = size;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/lab_tests/${core.url.encodePathParam(lab_test_id)}/markers`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GetMarkersResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/lab_tests/{lab_test_id}/markers",
        );
    }

    /**
     * GET a specific marker for the given lab and provider_id
     *
     * @param {number} lab_id
     * @param {string} provider_id
     * @param {Vital.LabTestsGetMarkersByLabAndProviderIdRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getMarkersByLabAndProviderId(1, "provider_id", {
     *         labAccountId: "lab_account_id"
     *     })
     */
    public getMarkersByLabAndProviderId(
        lab_id: number,
        provider_id: string,
        request: Vital.LabTestsGetMarkersByLabAndProviderIdRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingMarker> {
        return core.HttpResponsePromise.fromPromise(
            this.__getMarkersByLabAndProviderId(lab_id, provider_id, request, requestOptions),
        );
    }

    private async __getMarkersByLabAndProviderId(
        lab_id: number,
        provider_id: string,
        request: Vital.LabTestsGetMarkersByLabAndProviderIdRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingMarker>> {
        const { labAccountId } = request;
        const _queryParams: Record<string, unknown> = {};
        if (labAccountId != null) {
            _queryParams.lab_account_id = labAccountId;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/lab_tests/${core.url.encodePathParam(lab_id)}/markers/${core.url.encodePathParam(provider_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingMarker.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/lab_tests/{lab_id}/markers/{provider_id}",
        );
    }

    /**
     * GET all the labs.
     *
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labTests.getLabs()
     */
    public getLabs(requestOptions?: LabTestsClient.RequestOptions): core.HttpResponsePromise<Vital.ClientFacingLab[]> {
        return core.HttpResponsePromise.fromPromise(this.__getLabs(requestOptions));
    }

    private async __getLabs(
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingLab[]>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/lab_tests/labs",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.labTests.getLabs.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VitalError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/lab_tests/labs");
    }

    /**
     * GET lab tests the team has access to as a paginated list.
     *
     * @param {Vital.LabTestsGetPaginatedRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getPaginated({
     *         labTestLimit: 1,
     *         nextCursor: "next_cursor",
     *         generationMethod: "auto",
     *         labSlug: "lab_slug",
     *         collectionMethod: "testkit",
     *         status: "active",
     *         name: "name",
     *         orderKey: "price",
     *         orderDirection: "asc"
     *     })
     */
    public getPaginated(
        request: Vital.LabTestsGetPaginatedRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.LabTestResourcesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getPaginated(request, requestOptions));
    }

    private async __getPaginated(
        request: Vital.LabTestsGetPaginatedRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.LabTestResourcesResponse>> {
        const {
            labTestLimit,
            nextCursor,
            generationMethod,
            labSlug,
            collectionMethod,
            status,
            markerIds,
            providerIds,
            name,
            orderKey,
            orderDirection,
        } = request;
        const _queryParams: Record<string, unknown> = {};
        if (labTestLimit != null) {
            _queryParams.lab_test_limit = labTestLimit;
        }

        if (nextCursor != null) {
            _queryParams.next_cursor = nextCursor;
        }

        if (generationMethod != null) {
            _queryParams.generation_method = serializers.LabTestGenerationMethodFilter.jsonOrThrow(generationMethod, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (labSlug != null) {
            _queryParams.lab_slug = labSlug;
        }

        if (collectionMethod != null) {
            _queryParams.collection_method = serializers.LabTestCollectionMethod.jsonOrThrow(collectionMethod, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (status != null) {
            _queryParams.status = serializers.LabTestStatus.jsonOrThrow(status, { unrecognizedObjectKeys: "strip" });
        }

        if (markerIds != null) {
            if (Array.isArray(markerIds)) {
                _queryParams.marker_ids = markerIds.map((item) => item.toString());
            } else {
                _queryParams.marker_ids = markerIds;
            }
        }

        if (providerIds != null) {
            if (Array.isArray(providerIds)) {
                _queryParams.provider_ids = providerIds.map((item) => item);
            } else {
                _queryParams.provider_ids = providerIds;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (orderKey != null) {
            _queryParams.order_key = serializers.LabTestsGetPaginatedRequestOrderKey.jsonOrThrow(orderKey, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (orderDirection != null) {
            _queryParams.order_direction = serializers.LabTestsGetPaginatedRequestOrderDirection.jsonOrThrow(
                orderDirection,
                { unrecognizedObjectKeys: "strip" },
            );
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/lab_test",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.LabTestResourcesResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/lab_test");
    }

    /**
     * @throws {@link Vital.UnprocessableEntityError}
     */
    public getLabTestCollectionInstructionPdf(
        lab_test_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__getLabTestCollectionInstructionPdf(lab_test_id, requestOptions),
        );
    }

    private async __getLabTestCollectionInstructionPdf(
        lab_test_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/lab_test/${core.url.encodePathParam(lab_test_id)}/collection_instruction_pdf`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/lab_test/{lab_test_id}/collection_instruction_pdf",
        );
    }

    /**
     * GET many orders with filters.
     *
     * @param {Vital.LabTestsGetOrdersRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getOrders({
     *         searchInput: "search_input",
     *         startDate: new Date("2024-01-15T09:30:00.000Z"),
     *         endDate: new Date("2024-01-15T09:30:00.000Z"),
     *         updatedStartDate: new Date("2024-01-15T09:30:00.000Z"),
     *         updatedEndDate: new Date("2024-01-15T09:30:00.000Z"),
     *         orderKey: "created_at",
     *         orderDirection: "asc",
     *         isCritical: true,
     *         interpretation: "normal",
     *         userId: "user_id",
     *         patientName: "patient_name",
     *         shippingRecipientName: "shipping_recipient_name",
     *         page: 1,
     *         size: 1
     *     })
     */
    public getOrders(
        request: Vital.LabTestsGetOrdersRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.GetOrdersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getOrders(request, requestOptions));
    }

    private async __getOrders(
        request: Vital.LabTestsGetOrdersRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.GetOrdersResponse>> {
        const {
            searchInput,
            startDate,
            endDate,
            updatedStartDate,
            updatedEndDate,
            status,
            orderKey,
            orderDirection,
            orderType,
            isCritical,
            interpretation,
            orderActivationTypes,
            userId,
            patientName,
            shippingRecipientName,
            orderIds,
            page,
            size,
        } = request;
        const _queryParams: Record<string, unknown> = {};
        if (searchInput != null) {
            _queryParams.search_input = searchInput;
        }

        if (startDate != null) {
            _queryParams.start_date = startDate.toISOString();
        }

        if (endDate != null) {
            _queryParams.end_date = endDate.toISOString();
        }

        if (updatedStartDate != null) {
            _queryParams.updated_start_date = updatedStartDate.toISOString();
        }

        if (updatedEndDate != null) {
            _queryParams.updated_end_date = updatedEndDate.toISOString();
        }

        if (status != null) {
            if (Array.isArray(status)) {
                _queryParams.status = status.map((item) =>
                    serializers.OrderLowLevelStatus.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams.status = serializers.OrderLowLevelStatus.jsonOrThrow(status, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (orderKey != null) {
            _queryParams.order_key = serializers.LabTestsGetOrdersRequestOrderKey.jsonOrThrow(orderKey, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (orderDirection != null) {
            _queryParams.order_direction = serializers.LabTestsGetOrdersRequestOrderDirection.jsonOrThrow(
                orderDirection,
                { unrecognizedObjectKeys: "strip" },
            );
        }

        if (orderType != null) {
            if (Array.isArray(orderType)) {
                _queryParams.order_type = orderType.map((item) =>
                    serializers.LabTestCollectionMethod.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams.order_type = serializers.LabTestCollectionMethod.jsonOrThrow(orderType, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (isCritical != null) {
            _queryParams.is_critical = isCritical;
        }

        if (interpretation != null) {
            _queryParams.interpretation = serializers.Interpretation.jsonOrThrow(interpretation, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (orderActivationTypes != null) {
            if (Array.isArray(orderActivationTypes)) {
                _queryParams.order_activation_types = orderActivationTypes.map((item) =>
                    serializers.OrderActivationType.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams.order_activation_types = serializers.OrderActivationType.jsonOrThrow(
                    orderActivationTypes,
                    { unrecognizedObjectKeys: "strip" },
                );
            }
        }

        if (userId != null) {
            _queryParams.user_id = userId;
        }

        if (patientName != null) {
            _queryParams.patient_name = patientName;
        }

        if (shippingRecipientName != null) {
            _queryParams.shipping_recipient_name = shippingRecipientName;
        }

        if (orderIds != null) {
            if (Array.isArray(orderIds)) {
                _queryParams.order_ids = orderIds.map((item) => item);
            } else {
                _queryParams.order_ids = orderIds;
            }
        }

        if (page != null) {
            _queryParams.page = page;
        }

        if (size != null) {
            _queryParams.size = size;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/orders",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GetOrdersResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/orders");
    }

    /**
     * Return the available time slots to book an appointment with a phlebotomist
     * for the given address and order.
     *
     * @param {Vital.LabTestsGetPhlebotomyAppointmentAvailabilityRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getPhlebotomyAppointmentAvailability({
     *         startDate: "start_date",
     *         body: {
     *             firstLine: "first_line",
     *             city: "city",
     *             state: "state",
     *             zipCode: "zip_code"
     *         }
     *     })
     */
    public getPhlebotomyAppointmentAvailability(
        request: Vital.LabTestsGetPhlebotomyAppointmentAvailabilityRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.AppointmentAvailabilitySlots> {
        return core.HttpResponsePromise.fromPromise(
            this.__getPhlebotomyAppointmentAvailability(request, requestOptions),
        );
    }

    private async __getPhlebotomyAppointmentAvailability(
        request: Vital.LabTestsGetPhlebotomyAppointmentAvailabilityRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.AppointmentAvailabilitySlots>> {
        const { startDate, body: _body } = request;
        const _queryParams: Record<string, unknown> = {};
        if (startDate != null) {
            _queryParams.start_date = startDate;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/phlebotomy/appointment/availability",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.UsAddress.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.AppointmentAvailabilitySlots.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/order/phlebotomy/appointment/availability",
        );
    }

    /**
     * Book an at-home phlebotomy appointment.
     *
     * @param {string} order_id - Your Order ID.
     * @param {Vital.AppointmentBookingRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.bookPhlebotomyAppointment("order_id", {
     *         bookingKey: "booking_key"
     *     })
     */
    public bookPhlebotomyAppointment(
        order_id: string,
        request: Vital.AppointmentBookingRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(
            this.__bookPhlebotomyAppointment(order_id, request, requestOptions),
        );
    }

    private async __bookPhlebotomyAppointment(
        order_id: string,
        request: Vital.AppointmentBookingRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/phlebotomy/appointment/book`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.AppointmentBookingRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/order/{order_id}/phlebotomy/appointment/book",
        );
    }

    /**
     * Request an at-home phlebotomy appointment.
     *
     * @param {string} order_id - Your Order ID.
     * @param {Vital.RequestAppointmentRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.requestPhlebotomyAppointment("order_id", {
     *         address: {
     *             firstLine: "first_line",
     *             city: "city",
     *             state: "state",
     *             zipCode: "zip_code"
     *         },
     *         provider: "getlabs"
     *     })
     */
    public requestPhlebotomyAppointment(
        order_id: string,
        request: Vital.RequestAppointmentRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(
            this.__requestPhlebotomyAppointment(order_id, request, requestOptions),
        );
    }

    private async __requestPhlebotomyAppointment(
        order_id: string,
        request: Vital.RequestAppointmentRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/phlebotomy/appointment/request`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.RequestAppointmentRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/order/{order_id}/phlebotomy/appointment/request",
        );
    }

    /**
     * Reschedule a previously booked at-home phlebotomy appointment.
     *
     * @param {string} order_id - Your Order ID.
     * @param {Vital.AppointmentRescheduleRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.reschedulePhlebotomyAppointment("order_id", {
     *         bookingKey: "booking_key"
     *     })
     */
    public reschedulePhlebotomyAppointment(
        order_id: string,
        request: Vital.AppointmentRescheduleRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(
            this.__reschedulePhlebotomyAppointment(order_id, request, requestOptions),
        );
    }

    private async __reschedulePhlebotomyAppointment(
        order_id: string,
        request: Vital.AppointmentRescheduleRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/phlebotomy/appointment/reschedule`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.AppointmentRescheduleRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v3/order/{order_id}/phlebotomy/appointment/reschedule",
        );
    }

    /**
     * Cancel a previously booked at-home phlebotomy appointment.
     *
     * @param {string} order_id - Your Order ID.
     * @param {Vital.ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.cancelPhlebotomyAppointment("order_id", {
     *         cancellationReasonId: "cancellation_reason_id"
     *     })
     */
    public cancelPhlebotomyAppointment(
        order_id: string,
        request: Vital.ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(
            this.__cancelPhlebotomyAppointment(order_id, request, requestOptions),
        );
    }

    private async __cancelPhlebotomyAppointment(
        order_id: string,
        request: Vital.ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/phlebotomy/appointment/cancel`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest.jsonOrThrow(
                request,
                { unrecognizedObjectKeys: "strip" },
            ),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v3/order/{order_id}/phlebotomy/appointment/cancel",
        );
    }

    /**
     * Get the list of reasons for cancelling an at-home phlebotomy appointment.
     *
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labTests.getPhlebotomyAppointmentCancellationReason()
     */
    public getPhlebotomyAppointmentCancellationReason(
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointmentCancellationReason[]> {
        return core.HttpResponsePromise.fromPromise(this.__getPhlebotomyAppointmentCancellationReason(requestOptions));
    }

    private async __getPhlebotomyAppointmentCancellationReason(
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointmentCancellationReason[]>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/phlebotomy/appointment/cancellation-reasons",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.labTests.getPhlebotomyAppointmentCancellationReason.Response.parseOrThrow(
                    _response.body,
                    {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    },
                ),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VitalError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/phlebotomy/appointment/cancellation-reasons",
        );
    }

    /**
     * Get the appointment associated with an order.
     *
     * @param {string} order_id - Your Order ID.
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getPhlebotomyAppointment("order_id")
     */
    public getPhlebotomyAppointment(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(this.__getPhlebotomyAppointment(order_id, requestOptions));
    }

    private async __getPhlebotomyAppointment(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/phlebotomy/appointment`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/phlebotomy/appointment",
        );
    }

    /**
     * GET information about an area with respect to lab-testing.
     *
     * Information returned:
     * * Whether a given zip code is served by our Phlebotomy network.
     * * List of Lab locations in the area.
     *
     * @param {Vital.LabTestsGetAreaInfoRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getAreaInfo({
     *         zipCode: "zip_code",
     *         radius: "10",
     *         lab: "quest",
     *         labAccountId: "lab_account_id"
     *     })
     */
    public getAreaInfo(
        request: Vital.LabTestsGetAreaInfoRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.AreaInfo> {
        return core.HttpResponsePromise.fromPromise(this.__getAreaInfo(request, requestOptions));
    }

    private async __getAreaInfo(
        request: Vital.LabTestsGetAreaInfoRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.AreaInfo>> {
        const { zipCode, radius, lab, labs, labAccountId } = request;
        const _queryParams: Record<string, unknown> = {};
        _queryParams.zip_code = zipCode;
        if (radius != null) {
            _queryParams.radius = serializers.AllowedRadius.jsonOrThrow(radius, { unrecognizedObjectKeys: "strip" });
        }

        if (lab != null) {
            _queryParams.lab = serializers.ClientFacingLabs.jsonOrThrow(lab, { unrecognizedObjectKeys: "strip" });
        }

        if (labs != null) {
            if (Array.isArray(labs)) {
                _queryParams.labs = labs.map((item) =>
                    serializers.ClientFacingLabs.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams.labs = serializers.ClientFacingLabs.jsonOrThrow(labs, { unrecognizedObjectKeys: "strip" });
            }
        }

        if (labAccountId != null) {
            _queryParams.lab_account_id = labAccountId;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/area/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.AreaInfo.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/order/area/info");
    }

    /**
     * @param {Vital.LabTestsGetPscInfoRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getPscInfo({
     *         zipCode: "zip_code",
     *         labId: 1,
     *         radius: "10",
     *         labAccountId: "lab_account_id"
     *     })
     */
    public getPscInfo(
        request: Vital.LabTestsGetPscInfoRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.PscInfo> {
        return core.HttpResponsePromise.fromPromise(this.__getPscInfo(request, requestOptions));
    }

    private async __getPscInfo(
        request: Vital.LabTestsGetPscInfoRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.PscInfo>> {
        const { zipCode, labId, radius, capabilities, labAccountId } = request;
        const _queryParams: Record<string, unknown> = {};
        _queryParams.zip_code = zipCode;
        _queryParams.lab_id = labId;
        if (radius != null) {
            _queryParams.radius = serializers.AllowedRadius.jsonOrThrow(radius, { unrecognizedObjectKeys: "strip" });
        }

        if (capabilities != null) {
            if (Array.isArray(capabilities)) {
                _queryParams.capabilities = capabilities.map((item) =>
                    serializers.LabLocationCapability.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams.capabilities = serializers.LabLocationCapability.jsonOrThrow(capabilities, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (labAccountId != null) {
            _queryParams.lab_account_id = labAccountId;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/psc/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PscInfo.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/order/psc/info");
    }

    /**
     * @param {string} order_id - Your Order ID.
     * @param {Vital.LabTestsGetOrderPscInfoRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getOrderPscInfo("order_id", {
     *         radius: "10"
     *     })
     */
    public getOrderPscInfo(
        order_id: string,
        request: Vital.LabTestsGetOrderPscInfoRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.PscInfo> {
        return core.HttpResponsePromise.fromPromise(this.__getOrderPscInfo(order_id, request, requestOptions));
    }

    private async __getOrderPscInfo(
        order_id: string,
        request: Vital.LabTestsGetOrderPscInfoRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.PscInfo>> {
        const { radius, capabilities } = request;
        const _queryParams: Record<string, unknown> = {};
        if (radius != null) {
            _queryParams.radius = serializers.AllowedRadius.jsonOrThrow(radius, { unrecognizedObjectKeys: "strip" });
        }

        if (capabilities != null) {
            if (Array.isArray(capabilities)) {
                _queryParams.capabilities = capabilities.map((item) =>
                    serializers.LabLocationCapability.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams.capabilities = serializers.LabLocationCapability.jsonOrThrow(capabilities, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/psc/info`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PscInfo.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/order/{order_id}/psc/info");
    }

    /**
     * This endpoint returns the lab results for the order.
     * @throws {@link Vital.UnprocessableEntityError}
     */
    public getResultPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getResultPdf(order_id, requestOptions));
    }

    private async __getResultPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/result/pdf`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/result/pdf",
        );
    }

    /**
     * Return metadata related to order results, such as lab metadata,
     * provider and sample dates.
     *
     * @param {string} order_id
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getResultMetadata("order_id")
     */
    public getResultMetadata(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.LabResultsMetadata> {
        return core.HttpResponsePromise.fromPromise(this.__getResultMetadata(order_id, requestOptions));
    }

    private async __getResultMetadata(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.LabResultsMetadata>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/result/metadata`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.LabResultsMetadata.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/result/metadata",
        );
    }

    /**
     * Return both metadata and raw json test data
     *
     * @param {string} order_id
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getResultRaw("order_id")
     */
    public getResultRaw(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.LabResultsRaw> {
        return core.HttpResponsePromise.fromPromise(this.__getResultRaw(order_id, requestOptions));
    }

    private async __getResultRaw(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.LabResultsRaw>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/result`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.LabResultsRaw.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/order/{order_id}/result");
    }

    /**
     * This endpoint returns the printed labels for the order.
     * @throws {@link Vital.UnprocessableEntityError}
     */
    public getLabelsPdf(
        order_id: string,
        request: Vital.LabTestsGetLabelsPdfRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getLabelsPdf(order_id, request, requestOptions));
    }

    private async __getLabelsPdf(
        order_id: string,
        request: Vital.LabTestsGetLabelsPdfRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const { numberOfLabels, collectionDate } = request;
        const _queryParams: Record<string, unknown> = {};
        if (numberOfLabels != null) {
            _queryParams.number_of_labels = numberOfLabels;
        }

        _queryParams.collection_date = collectionDate.toISOString();
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/labels/pdf`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/labels/pdf",
        );
    }

    /**
     * @param {Vital.LabTestsGetPscAppointmentAvailabilityRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.NotFoundError}
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getPscAppointmentAvailability({
     *         lab: "quest",
     *         startDate: "start_date",
     *         zipCode: "zip_code",
     *         radius: "10"
     *     })
     */
    public getPscAppointmentAvailability(
        request: Vital.LabTestsGetPscAppointmentAvailabilityRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.AppointmentAvailabilitySlots> {
        return core.HttpResponsePromise.fromPromise(this.__getPscAppointmentAvailability(request, requestOptions));
    }

    private async __getPscAppointmentAvailability(
        request: Vital.LabTestsGetPscAppointmentAvailabilityRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.AppointmentAvailabilitySlots>> {
        const { lab, startDate, siteCodes, zipCode, radius } = request;
        const _queryParams: Record<string, unknown> = {};
        _queryParams.lab = serializers.AppointmentPscLabs.jsonOrThrow(lab, { unrecognizedObjectKeys: "strip" });
        if (startDate != null) {
            _queryParams.start_date = startDate;
        }

        if (siteCodes != null) {
            if (Array.isArray(siteCodes)) {
                _queryParams.site_codes = siteCodes.map((item) => item);
            } else {
                _queryParams.site_codes = siteCodes;
            }
        }

        if (zipCode != null) {
            _queryParams.zip_code = zipCode;
        }

        if (radius != null) {
            _queryParams.radius = serializers.AllowedRadius.jsonOrThrow(radius, { unrecognizedObjectKeys: "strip" });
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/psc/appointment/availability",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.AppointmentAvailabilitySlots.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Vital.NotFoundError(
                        serializers.NotFoundErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/order/psc/appointment/availability",
        );
    }

    /**
     * @param {string} order_id - Your Order ID.
     * @param {Vital.AppointmentBookingRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.bookPscAppointment("order_id", {
     *         bookingKey: "booking_key"
     *     })
     */
    public bookPscAppointment(
        order_id: string,
        request: Vital.AppointmentBookingRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(this.__bookPscAppointment(order_id, request, requestOptions));
    }

    private async __bookPscAppointment(
        order_id: string,
        request: Vital.AppointmentBookingRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/psc/appointment/book`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.AppointmentBookingRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/order/{order_id}/psc/appointment/book",
        );
    }

    /**
     * @param {string} order_id - Your Order ID.
     * @param {Vital.AppointmentRescheduleRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.reschedulePscAppointment("order_id", {
     *         bookingKey: "booking_key"
     *     })
     */
    public reschedulePscAppointment(
        order_id: string,
        request: Vital.AppointmentRescheduleRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(this.__reschedulePscAppointment(order_id, request, requestOptions));
    }

    private async __reschedulePscAppointment(
        order_id: string,
        request: Vital.AppointmentRescheduleRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/psc/appointment/reschedule`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.AppointmentRescheduleRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v3/order/{order_id}/psc/appointment/reschedule",
        );
    }

    /**
     * @param {string} order_id - Your Order ID.
     * @param {Vital.VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.cancelPscAppointment("order_id", {
     *         cancellationReasonId: "cancellationReasonId"
     *     })
     */
    public cancelPscAppointment(
        order_id: string,
        request: Vital.VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(this.__cancelPscAppointment(order_id, request, requestOptions));
    }

    private async __cancelPscAppointment(
        order_id: string,
        request: Vital.VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/psc/appointment/cancel`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v3/order/{order_id}/psc/appointment/cancel",
        );
    }

    /**
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labTests.getPscAppointmentCancellationReason()
     */
    public getPscAppointmentCancellationReason(
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointmentCancellationReason[]> {
        return core.HttpResponsePromise.fromPromise(this.__getPscAppointmentCancellationReason(requestOptions));
    }

    private async __getPscAppointmentCancellationReason(
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointmentCancellationReason[]>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/psc/appointment/cancellation-reasons",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.labTests.getPscAppointmentCancellationReason.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VitalError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/psc/appointment/cancellation-reasons",
        );
    }

    /**
     * Get the appointment associated with an order.
     *
     * @param {string} order_id - Your Order ID.
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getPscAppointment("order_id")
     */
    public getPscAppointment(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingAppointment> {
        return core.HttpResponsePromise.fromPromise(this.__getPscAppointment(order_id, requestOptions));
    }

    private async __getPscAppointment(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingAppointment>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/psc/appointment`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingAppointment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/psc/appointment",
        );
    }

    /**
     * GET collection instructions for an order
     * @throws {@link Vital.UnprocessableEntityError}
     */
    public getOrderCollectionInstructionPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getOrderCollectionInstructionPdf(order_id, requestOptions));
    }

    private async __getOrderCollectionInstructionPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/collection_instruction_pdf`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/collection_instruction_pdf",
        );
    }

    /**
     * GET requisition pdf for an order
     * @throws {@link Vital.UnprocessableEntityError}
     */
    public getOrderRequistionPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getOrderRequistionPdf(order_id, requestOptions));
    }

    private async __getOrderRequistionPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/requisition/pdf`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v3/order/{order_id}/requisition/pdf",
        );
    }

    /**
     * GET ABN pdf for an order
     * @throws {@link Vital.UnprocessableEntityError}
     */
    public getOrderAbnPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getOrderAbnPdf(order_id, requestOptions));
    }

    private async __getOrderAbnPdf(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/abn_pdf`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/order/{order_id}/abn_pdf");
    }

    /**
     * GET individual order by ID.
     *
     * @param {string} order_id - Your Order ID.
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.getOrder("order_id")
     */
    public getOrder(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ClientFacingOrder> {
        return core.HttpResponsePromise.fromPromise(this.__getOrder(order_id, requestOptions));
    }

    private async __getOrder(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ClientFacingOrder>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ClientFacingOrder.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v3/order/{order_id}");
    }

    /**
     * @param {Vital.CreateOrderRequestCompatible} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.createOrder({
     *         idempotencyKey: "X-Idempotency-Key",
     *         idempotencyError: "no-cache",
     *         userId: "user_id",
     *         patientDetails: {
     *             firstName: "first_name",
     *             lastName: "last_name",
     *             dob: "dob",
     *             gender: "female",
     *             phoneNumber: "phone_number",
     *             email: "email"
     *         },
     *         patientAddress: {
     *             firstLine: "first_line",
     *             city: "city",
     *             state: "state",
     *             zip: "zip",
     *             country: "country"
     *         }
     *     })
     */
    public createOrder(
        request: Vital.CreateOrderRequestCompatible,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.PostOrderResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createOrder(request, requestOptions));
    }

    private async __createOrder(
        request: Vital.CreateOrderRequestCompatible,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.PostOrderResponse>> {
        const { idempotencyKey, idempotencyError, ..._body } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Idempotency-Key": idempotencyKey, "X-Idempotency-Error": idempotencyError }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.CreateOrderRequestCompatible.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PostOrderResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v3/order");
    }

    /**
     * @param {Vital.ImportOrderBody} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.importOrder({
     *         userId: "user_id",
     *         billingType: "client_bill",
     *         orderSet: {},
     *         collectionMethod: "testkit",
     *         patientDetails: {
     *             firstName: "first_name",
     *             lastName: "last_name",
     *             dob: "dob",
     *             gender: "female",
     *             phoneNumber: "phone_number",
     *             email: "email"
     *         },
     *         patientAddress: {
     *             receiverName: "receiver_name",
     *             firstLine: "first_line",
     *             city: "city",
     *             state: "state",
     *             zip: "zip",
     *             country: "country"
     *         },
     *         sampleId: "sample_id"
     *     })
     */
    public importOrder(
        request: Vital.ImportOrderBody,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.PostOrderResponse> {
        return core.HttpResponsePromise.fromPromise(this.__importOrder(request, requestOptions));
    }

    private async __importOrder(
        request: Vital.ImportOrderBody,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.PostOrderResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/order/import",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.ImportOrderBody.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PostOrderResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v3/order/import");
    }

    /**
     * POST cancel order
     *
     * @param {string} order_id - Your Order ID.
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.cancelOrder("order_id")
     */
    public cancelOrder(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.PostOrderResponse> {
        return core.HttpResponsePromise.fromPromise(this.__cancelOrder(order_id, requestOptions));
    }

    private async __cancelOrder(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.PostOrderResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PostOrderResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v3/order/{order_id}/cancel");
    }

    /**
     * Get available test kits.
     *
     * @param {string} order_id
     * @param {Vital.LabTestsSimulateOrderProcessRequest} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.simulateOrderProcess("order_id", {
     *         finalStatus: "received.walk_in_test.ordered",
     *         delay: 1,
     *         body: {}
     *     })
     */
    public simulateOrderProcess(
        order_id: string,
        request: Vital.LabTestsSimulateOrderProcessRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__simulateOrderProcess(order_id, request, requestOptions));
    }

    private async __simulateOrderProcess(
        order_id: string,
        request: Vital.LabTestsSimulateOrderProcessRequest = {},
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { finalStatus, delay, body: _body } = request;
        const _queryParams: Record<string, unknown> = {};
        if (finalStatus != null) {
            _queryParams.final_status = serializers.OrderStatus.jsonOrThrow(finalStatus, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (delay != null) {
            _queryParams.delay = delay;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/test`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body:
                _body != null
                    ? serializers.labTests.simulateOrderProcess.Request.jsonOrThrow(_body, {
                          unrecognizedObjectKeys: "strip",
                      })
                    : undefined,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v3/order/{order_id}/test");
    }

    /**
     * PATCH update on site collection order when draw is completed
     *
     * @param {string} order_id - Your Order ID.
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.updateOnSiteCollectionOrderDrawCompleted("order_id")
     */
    public updateOnSiteCollectionOrderDrawCompleted(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.PostOrderResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateOnSiteCollectionOrderDrawCompleted(order_id, requestOptions),
        );
    }

    private async __updateOnSiteCollectionOrderDrawCompleted(
        order_id: string,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.PostOrderResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                `v3/order/${core.url.encodePathParam(order_id)}/draw_completed`,
            ),
            method: "PATCH",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PostOrderResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v3/order/{order_id}/draw_completed",
        );
    }

    /**
     * @param {Vital.ValidateIcdCodesBody} request
     * @param {LabTestsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vital.UnprocessableEntityError}
     *
     * @example
     *     await client.labTests.validateIcdCodes({
     *         codes: ["codes"]
     *     })
     */
    public validateIcdCodes(
        request: Vital.ValidateIcdCodesBody,
        requestOptions?: LabTestsClient.RequestOptions,
    ): core.HttpResponsePromise<Vital.ValidateIcdCodesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__validateIcdCodes(request, requestOptions));
    }

    private async __validateIcdCodes(
        request: Vital.ValidateIcdCodesBody,
        requestOptions?: LabTestsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vital.ValidateIcdCodesResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VitalEnvironment.Production,
                "v3/insurance/validate_icd_codes",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.ValidateIcdCodesBody.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ValidateIcdCodesResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Vital.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VitalError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v3/insurance/validate_icd_codes",
        );
    }
}
